{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "184dfd2c",
   "metadata": {},
   "source": [
    "# \ud83d\ude80 ITSM Ticket Similarity - Real ServiceNow Data Training (V2 + LoRA/PEFT)\n",
    "\n",
    "**Model:** `sentence-transformers/all-mpnet-base-v2` (768-dim embeddings) **+ LoRA adapters**  \n",
    "**Data:** Real ServiceNow incidents (Mar 2024 \u2192 Sep 2025, ~30K+ tickets)  \n",
    "**Use Case:** Find similar tickets, detect duplicates, assist routing\n",
    "\n",
    "## \ud83c\udd95 LoRA/PEFT Improvements (This Version)\n",
    "\n",
    "### 1. **Parameter-Efficient Fine-Tuning (LoRA)**\n",
    "- **90%+ parameter reduction**: Only ~3-5M trainable params vs ~30-50M full fine-tune\n",
    "- **LoRA rank**: 16, alpha: 32, targeting attention Q/V projections\n",
    "- **Faster training**: Reduced memory footprint and faster gradient updates\n",
    "- **Better generalization**: Less overfitting on domain-specific data\n",
    "- **Learning rate**: 1e-4 (optimized for LoRA vs 2e-5 for full fine-tune)\n",
    "\n",
    "### 2. **Multi-Loss Training**\n",
    "- **MultipleNegativesRankingLoss (90%)**: Primary loss for ranking/similarity ordering\n",
    "  - Leverages in-batch negatives for efficient contrastive learning\n",
    "  - Optimizes embedding space for relative similarity\n",
    "- **CosineSimilarityLoss (10%)**: Auxiliary loss for calibration\n",
    "  - Improves absolute similarity score calibration\n",
    "  - Better threshold-based binary classification (F1, precision, recall)\n",
    "  - Addresses the \"similarity score calibration\" gap\n",
    "\n",
    "**Why this combination?**\n",
    "- MNRL excels at ranking but may not calibrate absolute scores well\n",
    "- CosineSimilarity provides calibrated similarity values for thresholding\n",
    "- Together: Best of both worlds for ranking + classification tasks\n",
    "\n",
    "## V2 Base Improvements (Inherited)\n",
    "1. **Harder negative mining** \u2014 Increased hard_neg_ratio (35%\u219245%), stricter TF-IDF threshold (0.20\u21920.12)\n",
    "2. **Curriculum learning** \u2014 Progressive difficulty: easy pairs first, hard pairs later\n",
    "3. **Borderline test set** \u2014 New \"adversarial v2\" with TF-IDF 0.25-0.35 (ambiguous cases)\n",
    "4. **Error analysis** \u2014 Systematic failure pattern detection\n",
    "5. **Cross-validated threshold** \u2014 5-fold CV for robust production threshold\n",
    "\n",
    "## Key Differences from Dummy Data Pipeline\n",
    "1. **No Short Description** \u2014 Real data only has `Description` field\n",
    "2. **Rich vocabulary** \u2014 10K+ unique terms vs 111 in dummy data\n",
    "3. **Realistic metrics expected** \u2014 ROC-AUC 0.85-0.90, Spearman 0.65-0.75\n",
    "4. **No Resolution notes in training text** \u2014 Avoids data leakage for new tickets\n",
    "\n",
    "## Expected Benefits\n",
    "- **Training efficiency**: 2-3x faster with LoRA (fewer params to update)\n",
    "- **Memory savings**: Lower GPU memory usage enables larger batch sizes\n",
    "- **Performance**: Comparable or better than full fine-tune due to regularization\n",
    "- **Threshold calibration**: Improved binary classification metrics (F1, precision/recall)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "de9dc0f3",
   "metadata": {},
   "source": [
    "# 1. Environment Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "89658f5b",
   "metadata": {},
   "source": [
    "## \ud83d\udccb Quick Configuration Summary\n",
    "\n",
    "| Component | Setting | Rationale |\n",
    "|-----------|---------|-----------|\n",
    "| **LoRA Rank** | 16 | Balanced capacity (8=low, 32=high) |\n",
    "| **LoRA Alpha** | 32 | Standard scaling (2\u00d7rank) |\n",
    "| **Target Modules** | q_proj, v_proj | Attention query/value projections |\n",
    "| **Learning Rate** | 1e-4 | Lower than full fine-tune (2e-5) |\n",
    "| **MNRL Weight** | 0.9 | Primary ranking loss |\n",
    "| **Cosine Weight** | 0.1 | Auxiliary calibration |\n",
    "| **Batch Size** | 16 (8 on MPS) | Auto-adjusted for device |\n",
    "| **Epochs** | 4 | 2 phases \u00d7 2 epochs each |\n",
    "\n",
    "**Key Metrics to Watch:**\n",
    "- **Trainable params**: Should be ~3-5M (vs ~30-50M baseline)\n",
    "- **Spearman correlation**: Target > 0.75 (current V2 best: 0.7516)\n",
    "- **ROC-AUC**: Target > 0.93 (current V2 best: 0.9369)\n",
    "- **F1 @ optimal threshold**: Target > 0.84 (current V2 best: 0.8442)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "118e0c75",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\ud83d\udce6 Installing: importlib-metadata; python_version<\"3.11\"\n"
     ]
    }
   ],
   "source": [
    "import os, sys, subprocess\n",
    "from pathlib import Path\n",
    "\n",
    "# Environment variables to suppress warnings\n",
    "os.environ['WANDB_DISABLED'] = 'true'\n",
    "os.environ['WANDB_MODE'] = 'offline'\n",
    "os.environ['WANDB_SILENT'] = 'true'\n",
    "os.environ['HF_HUB_DISABLE_TELEMETRY'] = '1'\n",
    "os.environ['TOKENIZERS_PARALLELISM'] = 'false'\n",
    "os.environ[\"TF_CPP_MIN_LOG_LEVEL\"] = \"3\"\n",
    "os.environ[\"KMP_DUPLICATE_LIB_OK\"] = \"TRUE\"\n",
    "\n",
    "# Install required packages\n",
    "def ensure_packages():\n",
    "    try:\n",
    "        import importlib.metadata as importlib_metadata\n",
    "    except ImportError:\n",
    "        import importlib_metadata\n",
    "    \n",
    "    required = {\n",
    "        'sentence-transformers': 'sentence-transformers>=2.2.2',\n",
    "        'torch': 'torch',\n",
    "        'scikit-learn': 'scikit-learn>=1.3.0',\n",
    "        'pandas': 'pandas',\n",
    "        'numpy': 'numpy>=1.24.0',\n",
    "        'tqdm': 'tqdm',\n",
    "        'matplotlib': 'matplotlib',\n",
    "        'seaborn': 'seaborn',\n",
    "        'peft': 'peft>=0.4.0',  # LoRA/PEFT support\n",
    "        'transformers': 'transformers>=4.30.0',# Compatible with PEFT\n",
    "        'datasets': 'datasets>=2.13.1',\n",
    "        'importlib_metadata': 'importlib-metadata; python_version<\"3.11\"',\n",
    "    }\n",
    "    \n",
    "    missing = []\n",
    "    for name, spec in required.items():\n",
    "        try:\n",
    "            importlib_metadata.version(name)\n",
    "        except importlib_metadata.PackageNotFoundError:\n",
    "            missing.append(spec)\n",
    "    \n",
    "    if missing:\n",
    "        print(f'\ud83d\udce6 Installing: {\", \".join(missing)}')\n",
    "        subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--quiet', *missing])\n",
    "    else:\n",
    "        print('\u2705 All packages installed')\n",
    "\n",
    "ensure_packages()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c3f1ad25",
   "metadata": {},
   "source": [
    "# 2. Configuration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "6ae876b7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "======================================================================\n",
      "CONFIGURATION (V3 - Curriculum Learning)\n",
      "======================================================================\n",
      "Model: sentence-transformers/all-mpnet-base-v2\n",
      "Output: models/real_servicenow_finetuned_mpnet_lora\n",
      "\n",
      "Data:\n",
      "  Using pre-generated pairs: True\n",
      "  Pairs file: data_new/curriculum_training_pairs_20251224_065436.json\n",
      "\n",
      "LoRA Config:\n",
      "  Rank: 16\n",
      "  Alpha: 32\n",
      "  Dropout: 0.1\n",
      "\n",
      "Training:\n",
      "  Total epochs: 6\n",
      "  Learning rate: 5e-05 (INCREASED for LoRA)\n",
      "  Batch size: 16\n",
      "  Max seq length: 256 (REDUCED to match baseline)\n",
      "\n",
      "Curriculum:\n",
      "  Use curriculum: True\n",
      "  Epochs per phase: 2\n",
      "======================================================================\n"
     ]
    }
   ],
   "source": [
    "import random\n",
    "import numpy as np\n",
    "import torch\n",
    "import logging\n",
    "\n",
    "# Simple logging\n",
    "def log(msg, level=logging.INFO):\n",
    "    print(msg)\n",
    "\n",
    "# --- CONFIGURATION (V3 - Curriculum Learning with Pre-generated Pairs) ---\n",
    "CONFIG = {\n",
    "    # Model\n",
    "    'model_name': 'sentence-transformers/all-mpnet-base-v2',\n",
    "    'output_dir': 'models/real_servicenow_finetuned_mpnet_lora',\n",
    "\n",
    "    # Data - USING PRE-GENERATED CURRICULUM PAIRS\n",
    "    'use_pre_generated_pairs': True,  # NEW: Use pre-generated pairs\n",
    "    'train_pairs_path': 'data_new/curriculum_training_pairs_20251224_065436.json',  # NEW: Curriculum dataset\n",
    "    'source_data': 'data_new\\\\SNow_incident_ticket_data.csv',  # Fallback (not used)\n",
    "\n",
    "    # LoRA/PEFT Configuration\n",
    "    'use_lora': True,\n",
    "    'lora_r': 16,              # Rank (8-32, higher = more capacity)\n",
    "    'lora_alpha': 32,          # Scaling factor (typically 2*r)\n",
    "    'lora_dropout': 0.1,       # Dropout for LoRA layers\n",
    "    'lora_target_modules': ['query', 'key', 'value'],\n",
    "\n",
    "    # Loss Function\n",
    "    'use_multi_loss': False,   # Use single loss for simplicity\n",
    "    'loss_type': 'cosine',     # 'cosine' or 'mnrl'\n",
    "\n",
    "    # Training hyperparameters (UPDATED FOR CURRICULUM)\n",
    "    'epochs': 6,               # 6 total epochs (2 per curriculum phase)\n",
    "    'batch_size': 16,          # Will auto-reduce for MPS/CPU if needed\n",
    "    'lr': 5e-5,                # INCREASED from 2e-5 (LoRA needs higher LR)\n",
    "    'max_seq_length': 256,     # REDUCED from 384 (match baseline)\n",
    "    'warmup_ratio': 0.1,\n",
    "\n",
    "    # Curriculum Learning (NEW - Using phase_indicators from data)\n",
    "    'use_curriculum': True,    # Train in 3 phases\n",
    "    'epochs_per_phase': 2,     # 2 epochs per phase\n",
    "\n",
    "    # Data splits (only used if NOT using pre-generated)\n",
    "    'eval_split': 0.15,\n",
    "    'holdout_split': 0.10,\n",
    "    'min_text_length': 25,\n",
    "\n",
    "    # Pair generation (LEGACY - not used with pre-generated pairs)\n",
    "    'num_pairs': 50000,        # Not used\n",
    "    'pos_ratio': 0.30,         # Not used\n",
    "\n",
    "    # Reproducibility\n",
    "    'seed': 42\n",
    "}\n",
    "\n",
    "# Set seeds\n",
    "random.seed(CONFIG['seed'])\n",
    "np.random.seed(CONFIG['seed'])\n",
    "torch.manual_seed(CONFIG['seed'])\n",
    "\n",
    "log(\"=\"*70)\n",
    "log(\"CONFIGURATION (V3 - Curriculum Learning)\")\n",
    "log(\"=\"*70)\n",
    "log(f\"Model: {CONFIG['model_name']}\")\n",
    "log(f\"Output: {CONFIG['output_dir']}\")\n",
    "log(f\"\\nData:\")\n",
    "log(f\"  Using pre-generated pairs: {CONFIG['use_pre_generated_pairs']}\")\n",
    "log(f\"  Pairs file: {CONFIG['train_pairs_path']}\")\n",
    "log(f\"\\nLoRA Config:\")\n",
    "log(f\"  Rank: {CONFIG['lora_r']}\")\n",
    "log(f\"  Alpha: {CONFIG['lora_alpha']}\")\n",
    "log(f\"  Dropout: {CONFIG['lora_dropout']}\")\n",
    "log(f\"\\nTraining:\")\n",
    "log(f\"  Total epochs: {CONFIG['epochs']}\")\n",
    "log(f\"  Learning rate: {CONFIG['lr']} (INCREASED for LoRA)\")\n",
    "log(f\"  Batch size: {CONFIG['batch_size']}\")\n",
    "log(f\"  Max seq length: {CONFIG['max_seq_length']} (REDUCED to match baseline)\")\n",
    "log(f\"\\nCurriculum:\")\n",
    "log(f\"  Use curriculum: {CONFIG['use_curriculum']}\")\n",
    "log(f\"  Epochs per phase: {CONFIG['epochs_per_phase']}\")\n",
    "log(\"=\"*70)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "8903b0bf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch 2.11.0.dev20251223+cu128\n",
      "torchvision 0.25.0.dev20251223+cu128\n",
      "cuda? True\n",
      "cuda runtime 12.8\n",
      "NVIDIA GeForce RTX 5090\n",
      "cap (12, 0)\n"
     ]
    }
   ],
   "source": [
    "import torch\n",
    "import torchvision\n",
    "\n",
    "print('torch', torch.__version__)\n",
    "print('torchvision', torchvision.__version__)\n",
    "print('cuda?', torch.cuda.is_available())\n",
    "print('cuda runtime', getattr(torch.version, 'cuda', None))\n",
    "print(torch.cuda.get_device_name(0) if torch.cuda.is_available() else 'NO GPU')\n",
    "print('cap', torch.cuda.get_device_capability(0) if torch.cuda.is_available() else None)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "375b3f39",
   "metadata": {},
   "source": [
    "# 3. Data Loading & Preprocessing\n",
    "\n",
    "Load real ServiceNow incident data. Key differences from dummy data:\n",
    "- Only `Description` field (no Short Description)\n",
    "- Multi-line text with embedded newlines\n",
    "- Rich technical vocabulary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "3e629653",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\ud83d\udd0d Looking for data file:\n",
      "   Configured path: data_new\\SNow_incident_ticket_data.csv\n",
      "   Absolute path: C:\\Users\\donov\\Downloads\\nexustism\\nexustism\\data_new\\SNow_incident_ticket_data.csv\n",
      "   Current working directory: c:\\Users\\donov\\Downloads\\nexustism\\nexustism\n",
      "   File exists: True\n",
      "\ud83d\udcc2 Loading real ServiceNow data from: data_new\\SNow_incident_ticket_data.csv\n",
      "\ud83d\udcca Loaded 10,633 raw records\n",
      "\u2705 Available columns: ['Number', 'Description', 'Opened by', 'Company', 'ITSM Department', 'Created', 'Urgency', 'Impact', 'Priority', 'Assignment group', 'Assigned to', 'State', 'Service', 'Service offering', 'Closed', 'Closed by', 'Category', 'Subcategory', 'Resolution code', 'Resolution notes', 'User input', 'Comments and Work notes', 'Manday Effort (hrs)', 'Ticket Type', 'AMS Domain', 'AMS System Type', 'AMS Category Type', 'AMS Service Type', 'AMS Business Related', 'AMS IT Related']\n",
      "\ud83d\udcc9 After filtering short descriptions: 10,486 records (dropped 147)\n",
      "\n",
      "\ud83d\udcca Data Summary:\n",
      "   Total records: 10,486\n",
      "   Unique categories: 30\n",
      "   Avg text length: 561 chars\n",
      "   Min text length: 66 chars\n",
      "   Max text length: 15545 chars\n",
      "\n",
      "\ud83d\udcdd Sample preprocessed text:\n",
      "   'GRPT not working as expected. ZMMM_PO_REV is not generating correct dates as per maintained in GRPT table. E.g. P/O# 100024066 Vendor Ship mode is 03. As per GRPT route days are 12 days and GR days is...'\n",
      "\n",
      "\u2705 Loaded 10,486 incidents ready for training\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import re\n",
    "from pathlib import Path\n",
    "\n",
    "def load_and_preprocess_real_data(config):\n",
    "    \"\"\"\n",
    "    Load and preprocess real ServiceNow incident data.\n",
    "    \n",
    "    Key differences from dummy data:\n",
    "    - Only 'Description' column (no 'Short Description')\n",
    "    - Real data has multi-line descriptions with embedded newlines\n",
    "    - Richer vocabulary and more varied text\n",
    "    \"\"\"\n",
    "    source_path = Path(config['source_data'])\n",
    "    \n",
    "    # Debug: Show absolute path\n",
    "    log(f\"\ud83d\udd0d Looking for data file:\")\n",
    "    log(f\"   Configured path: {config['source_data']}\")\n",
    "    log(f\"   Absolute path: {source_path.resolve()}\")\n",
    "    log(f\"   Current working directory: {Path.cwd()}\")\n",
    "    log(f\"   File exists: {source_path.exists()}\")\n",
    "    \n",
    "    if not source_path.exists():\n",
    "        raise FileNotFoundError(f\"Data file not found: {source_path.resolve()}\")\n",
    "    \n",
    "    log(f\"\ud83d\udcc2 Loading real ServiceNow data from: {source_path}\")\n",
    "    \n",
    "    # Load CSV - handle multi-line fields\n",
    "    df = pd.read_csv(source_path, encoding='utf-8', on_bad_lines='skip')\n",
    "    initial_count = len(df)\n",
    "    log(f\"\ud83d\udcca Loaded {initial_count:,} raw records\")\n",
    "    \n",
    "    # Check required columns\n",
    "    required_cols = ['Number', 'Description', 'Category', 'Subcategory', \n",
    "                     'Service', 'Service offering', 'Assignment group']\n",
    "    missing_cols = [col for col in required_cols if col not in df.columns]\n",
    "    if missing_cols:\n",
    "        log(f\"\u26a0\ufe0f Missing columns: {missing_cols}\")\n",
    "        # Use available columns\n",
    "        required_cols = [col for col in required_cols if col in df.columns]\n",
    "    \n",
    "    log(f\"\u2705 Available columns: {list(df.columns)}\")\n",
    "    \n",
    "    # Clean text function\n",
    "    def clean_text(text):\n",
    "        if pd.isna(text) or text is None:\n",
    "            return \"\"\n",
    "        text = str(text).strip()\n",
    "        # Normalize whitespace (collapse multiple spaces/newlines)\n",
    "        text = re.sub(r'\\s+', ' ', text)\n",
    "        # Remove common boilerplate\n",
    "        text = re.sub(r'Note\\s*:\\s*This is an automated.*?\\.', '', text, flags=re.IGNORECASE)\n",
    "        return text.strip()\n",
    "    \n",
    "    # Clean Description\n",
    "    df['Description'] = df['Description'].apply(clean_text)\n",
    "    \n",
    "    # Fill NA for context columns\n",
    "    context_cols = ['Category', 'Subcategory', 'Service', 'Service offering', 'Assignment group']\n",
    "    for col in context_cols:\n",
    "        if col in df.columns:\n",
    "            df[col] = df[col].fillna('').astype(str).str.strip().str.lower()\n",
    "    \n",
    "    # Build contextual text representation\n",
    "    # Format: \"Description (Context: [Service|Offering] [Category|Subcategory] Group: X)\"\n",
    "    def build_context(row):\n",
    "        parts = []\n",
    "        \n",
    "        # Service context\n",
    "        service_parts = []\n",
    "        if row.get('Service', ''):\n",
    "            service_parts.append(row['Service'])\n",
    "        if row.get('Service offering', ''):\n",
    "            service_parts.append(row['Service offering'])\n",
    "        if service_parts:\n",
    "            parts.append(f\"[{' | '.join(service_parts)}]\")\n",
    "        \n",
    "        # Category context\n",
    "        cat_parts = []\n",
    "        if row.get('Category', ''):\n",
    "            cat_parts.append(row['Category'])\n",
    "        if row.get('Subcategory', ''):\n",
    "            cat_parts.append(row['Subcategory'])\n",
    "        if cat_parts:\n",
    "            parts.append(f\"[{' | '.join(cat_parts)}]\")\n",
    "        \n",
    "        # Assignment group\n",
    "        if row.get('Assignment group', ''):\n",
    "            parts.append(f\"Group: {row['Assignment group']}\")\n",
    "        \n",
    "        return ' '.join(parts) if parts else ''\n",
    "    \n",
    "    # Build full text: Description + Context suffix\n",
    "    df['context'] = df.apply(build_context, axis=1)\n",
    "    df['text'] = df.apply(\n",
    "        lambda row: f\"{row['Description']} (Context: {row['context']})\" if row['context'] else row['Description'],\n",
    "        axis=1\n",
    "    )\n",
    "    \n",
    "    # Filter out short/empty descriptions\n",
    "    df = df[df['Description'].str.len() >= config['min_text_length']].copy()\n",
    "    log(f\"\ud83d\udcc9 After filtering short descriptions: {len(df):,} records (dropped {initial_count - len(df):,})\")\n",
    "    \n",
    "    # Create category_id for stratified splitting\n",
    "    if 'Category' in df.columns and 'Subcategory' in df.columns:\n",
    "        df['category_id'] = df.groupby(['Category', 'Subcategory']).ngroup()\n",
    "    else:\n",
    "        df['category_id'] = 0\n",
    "    \n",
    "    # Reset index\n",
    "    df = df.reset_index(drop=True)\n",
    "    \n",
    "    # Summary stats\n",
    "    log(f\"\\n\ud83d\udcca Data Summary:\")\n",
    "    log(f\"   Total records: {len(df):,}\")\n",
    "    log(f\"   Unique categories: {df['category_id'].nunique()}\")\n",
    "    log(f\"   Avg text length: {df['text'].str.len().mean():.0f} chars\")\n",
    "    log(f\"   Min text length: {df['text'].str.len().min()} chars\")\n",
    "    log(f\"   Max text length: {df['text'].str.len().max()} chars\")\n",
    "    \n",
    "    # Sample text\n",
    "    log(f\"\\n\ud83d\udcdd Sample preprocessed text:\")\n",
    "    log(f\"   '{df['text'].iloc[0][:200]}...'\")\n",
    "    \n",
    "    return df\n",
    "\n",
    "# Load the data\n",
    "df_incidents = load_and_preprocess_real_data(CONFIG)\n",
    "print(f\"\\n\u2705 Loaded {len(df_incidents):,} incidents ready for training\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cb35dc0c",
   "metadata": {},
   "source": [
    "# 4. Data Splitting\n",
    "\n",
    "Split into Train / Eval / Holdout sets with stratification by category."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "32d80a32",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u2705 Using stratified split\n",
      "\ud83d\udcca Data Splits:\n",
      "   Train:   8,021 incidents (76.5%)\n",
      "   Eval:    1,416 incidents (13.5%)\n",
      "   Holdout: 1,049 incidents (10.0%)\n",
      "\n",
      "\ud83d\udd0d Overlap Check:\n",
      "   Train \u2229 Eval: 0 incidents\n",
      "   Train \u2229 Holdout: 0 incidents\n",
      "   Eval \u2229 Holdout: 0 incidents\n"
     ]
    }
   ],
   "source": [
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "def split_data(df, config):\n",
    "    \"\"\"\n",
    "    Three-way split: Train / Eval / Holdout\n",
    "    - Holdout is completely unseen (for adversarial diagnostic)\n",
    "    - Stratified by category to ensure representation\n",
    "    \"\"\"\n",
    "    # Handle rare categories: group categories with <2 samples\n",
    "    category_counts = df['category_id'].value_counts()\n",
    "    rare_categories = category_counts[category_counts < 2].index\n",
    "    \n",
    "    # Create stratification column: use category_id for common categories, -1 for rare\n",
    "    df['stratify_col'] = df['category_id'].copy()\n",
    "    df.loc[df['category_id'].isin(rare_categories), 'stratify_col'] = -1\n",
    "    \n",
    "    # Check if we can stratify (need at least 2 samples per class)\n",
    "    stratify_counts = df['stratify_col'].value_counts()\n",
    "    can_stratify = all(stratify_counts >= 2)\n",
    "    \n",
    "    if can_stratify:\n",
    "        # First split: separate holdout set (stratified)\n",
    "        train_eval_df, holdout_df = train_test_split(\n",
    "            df,\n",
    "            test_size=config['holdout_split'],\n",
    "            stratify=df['stratify_col'],\n",
    "            random_state=config['seed']\n",
    "        )\n",
    "        \n",
    "        # Second split: train/eval from remaining (stratified)\n",
    "        train_df, eval_df = train_test_split(\n",
    "            train_eval_df,\n",
    "            test_size=config['eval_split'],\n",
    "            stratify=train_eval_df['stratify_col'],\n",
    "            random_state=config['seed']\n",
    "        )\n",
    "        log(\"\u2705 Using stratified split\")\n",
    "    else:\n",
    "        # Fallback: random split without stratification\n",
    "        log(\"\u26a0\ufe0f Using random split (categories too imbalanced for stratification)\")\n",
    "        train_eval_df, holdout_df = train_test_split(\n",
    "            df,\n",
    "            test_size=config['holdout_split'],\n",
    "            random_state=config['seed']\n",
    "        )\n",
    "        \n",
    "        train_df, eval_df = train_test_split(\n",
    "            train_eval_df,\n",
    "            test_size=config['eval_split'],\n",
    "            random_state=config['seed']\n",
    "        )\n",
    "    \n",
    "    return train_df, eval_df, holdout_df\n",
    "\n",
    "# Split the data\n",
    "train_df, eval_df, holdout_df = split_data(df_incidents, CONFIG)\n",
    "\n",
    "log(f\"\ud83d\udcca Data Splits:\")\n",
    "log(f\"   Train:   {len(train_df):,} incidents ({len(train_df)/len(df_incidents)*100:.1f}%)\")\n",
    "log(f\"   Eval:    {len(eval_df):,} incidents ({len(eval_df)/len(df_incidents)*100:.1f}%)\")\n",
    "log(f\"   Holdout: {len(holdout_df):,} incidents ({len(holdout_df)/len(df_incidents)*100:.1f}%)\")\n",
    "\n",
    "# Check for data leakage\n",
    "def check_overlap(df1, df2, name1, name2):\n",
    "    overlap = len(set(df1['Number']) & set(df2['Number']))\n",
    "    log(f\"   {name1} \u2229 {name2}: {overlap} incidents\")\n",
    "\n",
    "log(f\"\\n\ud83d\udd0d Overlap Check:\")\n",
    "check_overlap(train_df, eval_df, \"Train\", \"Eval\")\n",
    "check_overlap(train_df, holdout_df, \"Train\", \"Holdout\")\n",
    "check_overlap(eval_df, holdout_df, \"Eval\", \"Holdout\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "b68d81eb",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "c:\\Users\\donov\\anaconda3\\envs\\itsm\\Lib\\site-packages\\tqdm\\auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n",
      "  from .autonotebook import tqdm as notebook_tqdm\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u2699\ufe0f  Running in WANDB offline mode\n",
      "======================================================================\n",
      "USING PRE-GENERATED CURRICULUM PAIRS\n",
      "======================================================================\n",
      "\n",
      "Loading curriculum pairs from: data_new/curriculum_training_pairs_20251224_065436.json\n",
      "Loaded 15,000 total pairs\n",
      "  Positives: 10,000 (66.7%)\n",
      "  Negatives: 5,000 (33.3%)\n",
      "\n",
      "Curriculum phases: 3\n",
      "  Phase 1 (easy): 5,000 pairs, pos>=0.52, neg<=0.36\n",
      "  Phase 2 (medium): 5,000 pairs, pos>=0.4, neg<=0.45\n",
      "  Phase 3 (hard): 5,000 pairs, pos>=0.3, neg<=0.5\n",
      "\n",
      "Separated into phases:\n",
      "  Phase 1: 5,000 pairs\n",
      "  Phase 2: 5,000 pairs\n",
      "  Phase 3: 5,000 pairs\n",
      "\n",
      "Total training examples: 15,000\n",
      "\n",
      "Note: Will train in 3 curriculum phases\n"
     ]
    }
   ],
   "source": [
    "# ========================================\n",
    "# LOAD PRE-GENERATED CURRICULUM PAIRS\n",
    "# ========================================\n",
    "\n",
    "import json\n",
    "from sentence_transformers import InputExample\n",
    "\n",
    "def load_curriculum_pairs(pairs_path, use_curriculum=True):\n",
    "    \"\"\"\n",
    "    Load pre-generated curriculum pairs from JSON file.\n",
    "    \n",
    "    Args:\n",
    "        pairs_path: Path to curriculum_training_pairs_*.json\n",
    "        use_curriculum: If True, return separate phases; if False, return all mixed\n",
    "    \n",
    "    Returns:\n",
    "        If use_curriculum=True: (phase1_pairs, phase2_pairs, phase3_pairs)\n",
    "        If use_curriculum=False: all_pairs (mixed)\n",
    "    \"\"\"\n",
    "    log(f\"\\nLoading curriculum pairs from: {pairs_path}\")\n",
    "    \n",
    "    with open(pairs_path, 'r', encoding='utf-8') as f:\n",
    "        data = json.load(f)\n",
    "    \n",
    "    texts1 = data['texts1']\n",
    "    texts2 = data['texts2']\n",
    "    labels = data['labels']\n",
    "    phase_indicators = data.get('phase_indicators', [1] * len(labels))\n",
    "    \n",
    "    log(f\"Loaded {len(labels):,} total pairs\")\n",
    "    log(f\"  Positives: {sum(labels):,} ({100*sum(labels)/len(labels):.1f}%)\")\n",
    "    log(f\"  Negatives: {len(labels) - sum(labels):,} ({100*(len(labels)-sum(labels))/len(labels):.1f}%)\")\n",
    "    \n",
    "    # Show metadata\n",
    "    metadata = data.get('metadata', {})\n",
    "    if metadata:\n",
    "        log(f\"\\nCurriculum phases: {metadata.get('curriculum_phases', 'N/A')}\")\n",
    "        for phase_num in [1, 2, 3]:\n",
    "            phase_key = f'phase{phase_num}_config'\n",
    "            if phase_key in metadata:\n",
    "                phase_cfg = metadata[phase_key]\n",
    "                log(f\"  Phase {phase_num} ({phase_cfg.get('difficulty', 'N/A')}): \"\n",
    "                    f\"{phase_cfg.get('pairs', 0):,} pairs, \"\n",
    "                    f\"pos>={phase_cfg.get('pos_threshold', 'N/A')}, \"\n",
    "                    f\"neg<={phase_cfg.get('neg_threshold', 'N/A')}\")\n",
    "    \n",
    "    # Convert to InputExample format\n",
    "    if use_curriculum:\n",
    "        # Separate by phase\n",
    "        phase1_pairs = []\n",
    "        phase2_pairs = []\n",
    "        phase3_pairs = []\n",
    "        \n",
    "        for i in range(len(labels)):\n",
    "            example = InputExample(texts=[texts1[i], texts2[i]], label=float(labels[i]))\n",
    "            phase = phase_indicators[i]\n",
    "            if phase == 1:\n",
    "                phase1_pairs.append(example)\n",
    "            elif phase == 2:\n",
    "                phase2_pairs.append(example)\n",
    "            elif phase == 3:\n",
    "                phase3_pairs.append(example)\n",
    "        \n",
    "        log(f\"\\nSeparated into phases:\")\n",
    "        log(f\"  Phase 1: {len(phase1_pairs):,} pairs\")\n",
    "        log(f\"  Phase 2: {len(phase2_pairs):,} pairs\")\n",
    "        log(f\"  Phase 3: {len(phase3_pairs):,} pairs\")\n",
    "        \n",
    "        return phase1_pairs, phase2_pairs, phase3_pairs\n",
    "    else:\n",
    "        # Return all mixed\n",
    "        all_pairs = [\n",
    "            InputExample(texts=[texts1[i], texts2[i]], label=float(labels[i]))\n",
    "            for i in range(len(labels))\n",
    "        ]\n",
    "        log(f\"Returning {len(all_pairs):,} mixed pairs\")\n",
    "        return all_pairs\n",
    "\n",
    "# ========================================\n",
    "# LOAD OR GENERATE PAIRS\n",
    "# ========================================\n",
    "\n",
    "if CONFIG.get('use_pre_generated_pairs', False):\n",
    "    log(\"=\"*70)\n",
    "    log(\"USING PRE-GENERATED CURRICULUM PAIRS\")\n",
    "    log(\"=\"*70)\n",
    "    \n",
    "    pairs_path = CONFIG['train_pairs_path']\n",
    "    \n",
    "    if CONFIG.get('use_curriculum', False):\n",
    "        # Load phases separately for curriculum training\n",
    "        phase1_train, phase2_train, phase3_train = load_curriculum_pairs(\n",
    "            pairs_path, use_curriculum=True\n",
    "        )\n",
    "        \n",
    "        # For now, combine for evaluation split\n",
    "        # (In production, you'd want separate eval sets per phase)\n",
    "        train_examples = phase1_train + phase2_train + phase3_train\n",
    "        \n",
    "        log(f\"\\nTotal training examples: {len(train_examples):,}\")\n",
    "        log(\"\\nNote: Will train in 3 curriculum phases\")\n",
    "        \n",
    "        # Store phases for later use\n",
    "        CURRICULUM_PHASES = {\n",
    "            'phase1': phase1_train,\n",
    "            'phase2': phase2_train,\n",
    "            'phase3': phase3_train\n",
    "        }\n",
    "    else:\n",
    "        # Load all mixed\n",
    "        train_examples = load_curriculum_pairs(pairs_path, use_curriculum=False)\n",
    "        CURRICULUM_PHASES = None\n",
    "    \n",
    "    # Skip the pair generation cells below\n",
    "    SKIP_PAIR_GENERATION = True\n",
    "    \n",
    "else:\n",
    "    log(\"=\"*70)\n",
    "    log(\"GENERATING PAIRS ON-THE-FLY (LEGACY MODE)\")\n",
    "    log(\"=\"*70)\n",
    "    log(\"Note: Consider using pre-generated curriculum pairs instead!\")\n",
    "    log(\"      Run fix_train_test_mismatch.ipynb to generate them.\")\n",
    "    \n",
    "    SKIP_PAIR_GENERATION = False\n",
    "    CURRICULUM_PHASES = None\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eadfadea",
   "metadata": {},
   "source": [
    "# 5. Pair Generation\n",
    "\n",
    "Generate training pairs using TF-IDF similarity mining:\n",
    "- **35% Positives**: High TF-IDF similarity (> 0.35)\n",
    "- **35% Hard Negatives**: Same category, low TF-IDF (< 0.20)\n",
    "- **30% Easy Negatives**: Different category, low TF-IDF\n",
    "\n",
    "This forces the model to learn semantic content, not just category matching."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "9ff4c6d1",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.feature_extraction.text import TfidfVectorizer\n",
    "from sentence_transformers import InputExample\n",
    "from tqdm.auto import tqdm\n",
    "import gc\n",
    "\n",
    "class TFIDFSimilarityCalculator:\n",
    "    \"\"\"Efficient TF-IDF similarity calculator for large datasets.\"\"\"\n",
    "    \n",
    "    def __init__(self, texts, max_features=15000):\n",
    "        log(\"\u23f3 Building TF-IDF matrix...\")\n",
    "        self.vectorizer = TfidfVectorizer(\n",
    "            max_features=max_features,\n",
    "            stop_words='english',\n",
    "            ngram_range=(1, 2),  # Unigrams + bigrams for better matching\n",
    "            min_df=2,           # Ignore very rare terms\n",
    "            max_df=0.95         # Ignore very common terms\n",
    "        )\n",
    "        self.tfidf_matrix = self.vectorizer.fit_transform(texts)\n",
    "        log(f\"\u2705 TF-IDF matrix: {self.tfidf_matrix.shape} (vocab size: {len(self.vectorizer.vocabulary_)})\")\n",
    "    \n",
    "    def similarity(self, idx1, idx2):\n",
    "        \"\"\"Compute cosine similarity between two documents.\"\"\"\n",
    "        if idx1 >= self.tfidf_matrix.shape[0] or idx2 >= self.tfidf_matrix.shape[0]:\n",
    "            return 0.0\n",
    "        vec1 = self.tfidf_matrix[idx1]\n",
    "        vec2 = self.tfidf_matrix[idx2]\n",
    "        return (vec1 @ vec2.T).toarray()[0][0]\n",
    "\n",
    "\n",
    "def generate_training_pairs(df, target_count, config, desc=\"\", phase_config=None, tfidf_calc=None):\n",
    "    \"\"\"\n",
    "    Generate training pairs with configurable split (V2: supports curriculum phases).\n",
    "    \n",
    "    Args:\n",
    "        df: DataFrame with ticket data\n",
    "        target_count: Total number of pairs to generate\n",
    "        config: Main configuration dict\n",
    "        desc: Description for logging\n",
    "        phase_config: Optional override for curriculum learning phase\n",
    "        tfidf_calc: Optional precomputed TF-IDF calculator to avoid rebuilding\n",
    "    \"\"\"\n",
    "    df = df.reset_index(drop=True)\n",
    "    \n",
    "    # Use phase config if provided (for curriculum learning)\n",
    "    pos_ratio = config['pos_ratio']\n",
    "    hard_neg_ratio = phase_config['hard_neg_ratio'] if phase_config else config['hard_neg_ratio']\n",
    "    neg_threshold = phase_config['neg_threshold'] if phase_config else config['neg_tfidf_threshold']\n",
    "    easy_neg_ratio = 1.0 - pos_ratio - hard_neg_ratio\n",
    "    \n",
    "    # Build or reuse TF-IDF for this split\n",
    "    created_tfidf = False\n",
    "    if tfidf_calc is None:\n",
    "        tfidf_calc = TFIDFSimilarityCalculator(df['text'].tolist())\n",
    "        created_tfidf = True\n",
    "    \n",
    "    # Calculate targets\n",
    "    pos_target = int(target_count * pos_ratio)\n",
    "    hard_neg_target = int(target_count * hard_neg_ratio)\n",
    "    easy_neg_target = target_count - pos_target - hard_neg_target\n",
    "    \n",
    "    pairs = []\n",
    "    all_indices = list(df.index)\n",
    "    \n",
    "    # Group by category for hard negatives\n",
    "    category_groups = df.groupby('category_id').indices\n",
    "    valid_groups = {k: list(v) for k, v in category_groups.items() if len(v) >= 2}\n",
    "    \n",
    "    log(f\"\\n\ud83c\udfaf Generating {target_count:,} pairs for {desc}:\")\n",
    "    log(f\"   Target: {pos_target:,} positives ({pos_ratio*100:.0f}%), {hard_neg_target:,} hard neg ({hard_neg_ratio*100:.0f}%), {easy_neg_target:,} easy neg\")\n",
    "    log(f\"   Neg TF-IDF threshold: {neg_threshold}\")\n",
    "    \n",
    "    # ============================================\n",
    "    # 1. POSITIVES: High TF-IDF similarity (> threshold)\n",
    "    # ============================================\n",
    "    pbar = tqdm(total=pos_target, desc=\"Positives (high TF-IDF)\")\n",
    "    attempts, max_attempts = 0, pos_target * 50\n",
    "    \n",
    "    while len(pairs) < pos_target and attempts < max_attempts:\n",
    "        attempts += 1\n",
    "        i1, i2 = random.sample(all_indices, 2)\n",
    "        if i1 == i2:\n",
    "            continue\n",
    "        \n",
    "        sim = tfidf_calc.similarity(i1, i2)\n",
    "        if sim > config['pos_tfidf_threshold']:\n",
    "            pairs.append(InputExample(\n",
    "                texts=[df.at[i1, 'text'], df.at[i2, 'text']],\n",
    "                label=1.0\n",
    "            ))\n",
    "            pbar.update(1)\n",
    "    pbar.close()\n",
    "    actual_pos = len(pairs)\n",
    "    \n",
    "    # ============================================\n",
    "    # 2. HARD NEGATIVES: Same category, low TF-IDF (V2: stricter threshold)\n",
    "    # ============================================\n",
    "    current_len = len(pairs)\n",
    "    pbar = tqdm(total=hard_neg_target, desc=f\"Hard Negatives (same cat, TF-IDF<{neg_threshold})\")\n",
    "    attempts, max_attempts = 0, hard_neg_target * 50\n",
    "    \n",
    "    while (len(pairs) - current_len) < hard_neg_target and attempts < max_attempts:\n",
    "        attempts += 1\n",
    "        if not valid_groups:\n",
    "            break\n",
    "        \n",
    "        # Pick a random category with 2+ members\n",
    "        gid = random.choice(list(valid_groups.keys()))\n",
    "        g_indices = valid_groups[gid]\n",
    "        if len(g_indices) < 2:\n",
    "            continue\n",
    "        \n",
    "        i1, i2 = random.sample(g_indices, 2)\n",
    "        sim = tfidf_calc.similarity(i1, i2)\n",
    "        \n",
    "        if sim < neg_threshold:  # V2: Uses stricter threshold\n",
    "            pairs.append(InputExample(\n",
    "                texts=[df.at[i1, 'text'], df.at[i2, 'text']],\n",
    "                label=0.0\n",
    "            ))\n",
    "            pbar.update(1)\n",
    "    pbar.close()\n",
    "    actual_hard = len(pairs) - current_len\n",
    "    \n",
    "    # ============================================\n",
    "    # 3. EASY NEGATIVES: Cross-category, low TF-IDF\n",
    "    # ============================================\n",
    "    current_len = len(pairs)\n",
    "    pbar = tqdm(total=easy_neg_target, desc=\"Easy Negatives (cross-cat)\")\n",
    "    attempts, max_attempts = 0, easy_neg_target * 50\n",
    "    \n",
    "    while (len(pairs) - current_len) < easy_neg_target and attempts < max_attempts:\n",
    "        attempts += 1\n",
    "        i1, i2 = random.sample(all_indices, 2)\n",
    "        \n",
    "        # Must be different categories\n",
    "        if df.at[i1, 'category_id'] == df.at[i2, 'category_id']:\n",
    "            continue\n",
    "        \n",
    "        sim = tfidf_calc.similarity(i1, i2)\n",
    "        if sim < neg_threshold:\n",
    "            pairs.append(InputExample(\n",
    "                texts=[df.at[i1, 'text'], df.at[i2, 'text']],\n",
    "                label=0.0\n",
    "            ))\n",
    "            pbar.update(1)\n",
    "    pbar.close()\n",
    "    actual_easy = len(pairs) - current_len\n",
    "    \n",
    "    # Summary\n",
    "    total_pos = sum(1 for p in pairs if p.label == 1.0)\n",
    "    total_neg = len(pairs) - total_pos\n",
    "    \n",
    "    log(f\"\u2705 Generated {len(pairs):,} pairs:\")\n",
    "    log(f\"   Positives: {actual_pos:,} ({actual_pos/len(pairs)*100:.1f}%)\")\n",
    "    log(f\"   Hard Neg:  {actual_hard:,} ({actual_hard/len(pairs)*100:.1f}%)\")\n",
    "    log(f\"   Easy Neg:  {actual_easy:,} ({actual_easy/len(pairs)*100:.1f}%)\")\n",
    "    \n",
    "    # Clean up TF-IDF to free memory only if we created it here\n",
    "    if created_tfidf:\n",
    "        del tfidf_calc\n",
    "        gc.collect()\n",
    "    \n",
    "    return pairs\n",
    "\n",
    "\n",
    "def generate_borderline_pairs(df, target_count, config, desc=\"Borderline\", tfidf_calc=None):\n",
    "    \"\"\"\n",
    "    V2 NEW: Generate borderline/ambiguous pairs for harder evaluation.\n",
    "    \n",
    "    These are pairs with TF-IDF similarity in the 0.25-0.35 range - \n",
    "    cases where it's genuinely hard to determine similarity.\n",
    "    \"\"\"\n",
    "    df = df.reset_index(drop=True)\n",
    "    created_tfidf = False\n",
    "    if tfidf_calc is None:\n",
    "        tfidf_calc = TFIDFSimilarityCalculator(df['text'].tolist())\n",
    "        created_tfidf = True\n",
    "    \n",
    "    borderline_pairs = []\n",
    "    all_indices = list(df.index)\n",
    "    \n",
    "    # TF-IDF range for borderline cases\n",
    "    low_threshold = 0.25\n",
    "    high_threshold = 0.35\n",
    "    \n",
    "    log(f\"\\n\ud83c\udfaf Generating {target_count:,} borderline pairs ({desc}):\")\n",
    "    log(f\"   TF-IDF range: {low_threshold} - {high_threshold}\")\n",
    "    \n",
    "    pbar = tqdm(total=target_count, desc=\"Borderline pairs\")\n",
    "    attempts, max_attempts = 0, target_count * 100\n",
    "    \n",
    "    while len(borderline_pairs) < target_count and attempts < max_attempts:\n",
    "        attempts += 1\n",
    "        i1, i2 = random.sample(all_indices, 2)\n",
    "        if i1 == i2:\n",
    "            continue\n",
    "        \n",
    "        sim = tfidf_calc.similarity(i1, i2)\n",
    "        \n",
    "        # Borderline: medium TF-IDF similarity (ambiguous)\n",
    "        if low_threshold <= sim <= high_threshold:\n",
    "            # Label based on same category (proxy for similarity)\n",
    "            same_cat = df.at[i1, 'category_id'] == df.at[i2, 'category_id']\n",
    "            label = 1.0 if same_cat else 0.0\n",
    "            \n",
    "            borderline_pairs.append(InputExample(\n",
    "                texts=[df.at[i1, 'text'], df.at[i2, 'text']],\n",
    "                label=label\n",
    "            ))\n",
    "            pbar.update(1)\n",
    "    \n",
    "    pbar.close()\n",
    "    \n",
    "    pos_count = sum(1 for p in borderline_pairs if p.label == 1.0)\n",
    "    log(f\"\u2705 Generated {len(borderline_pairs):,} borderline pairs:\")\n",
    "    log(f\"   Positives: {pos_count:,} ({pos_count/len(borderline_pairs)*100:.1f}%)\")\n",
    "    log(f\"   Negatives: {len(borderline_pairs)-pos_count:,}\")\n",
    "    \n",
    "    if created_tfidf:\n",
    "        del tfidf_calc\n",
    "        gc.collect()\n",
    "    \n",
    "    return borderline_pairs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "1053863e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\ud83e\udde0 Building reusable TF-IDF matrices (one per split)...\n",
      "\u23f3 Building TF-IDF matrix...\n",
      "\u2705 TF-IDF matrix: (8021, 15000) (vocab size: 15000)\n",
      "\u23f3 Building TF-IDF matrix...\n",
      "\u2705 TF-IDF matrix: (1416, 5532) (vocab size: 5532)\n",
      "\u23f3 Building TF-IDF matrix...\n",
      "\u2705 TF-IDF matrix: (1049, 5256) (vocab size: 5256)\n"
     ]
    },
    {
     "ename": "KeyError",
     "evalue": "'hard_neg_ratio'",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mKeyError\u001b[39m                                  Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[8]\u001b[39m\u001b[32m, line 14\u001b[39m\n\u001b[32m     11\u001b[39m tfidf_holdout = TFIDFSimilarityCalculator(holdout_df[\u001b[33m'\u001b[39m\u001b[33mtext\u001b[39m\u001b[33m'\u001b[39m].tolist())\n\u001b[32m     13\u001b[39m \u001b[38;5;66;03m# Generate pairs using shared TF-IDF calculators\u001b[39;00m\n\u001b[32m---> \u001b[39m\u001b[32m14\u001b[39m train_examples = \u001b[43mgenerate_training_pairs\u001b[49m\u001b[43m(\u001b[49m\u001b[43mtrain_df\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mtrain_pair_count\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mCONFIG\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdesc\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m\"\u001b[39;49m\u001b[33;43mTraining\u001b[39;49m\u001b[33;43m\"\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mtfidf_calc\u001b[49m\u001b[43m=\u001b[49m\u001b[43mtfidf_train\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m     15\u001b[39m eval_examples = generate_training_pairs(eval_df, eval_pair_count, CONFIG, desc=\u001b[33m\"\u001b[39m\u001b[33mEvaluation\u001b[39m\u001b[33m\"\u001b[39m, tfidf_calc=tfidf_eval)\n\u001b[32m     16\u001b[39m holdout_examples = generate_training_pairs(holdout_df, holdout_pair_count, CONFIG, desc=\u001b[33m\"\u001b[39m\u001b[33mHoldout\u001b[39m\u001b[33m\"\u001b[39m, tfidf_calc=tfidf_holdout)\n",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[7]\u001b[39m\u001b[32m, line 46\u001b[39m, in \u001b[36mgenerate_training_pairs\u001b[39m\u001b[34m(df, target_count, config, desc, phase_config, tfidf_calc)\u001b[39m\n\u001b[32m     44\u001b[39m \u001b[38;5;66;03m# Use phase config if provided (for curriculum learning)\u001b[39;00m\n\u001b[32m     45\u001b[39m pos_ratio = config[\u001b[33m'\u001b[39m\u001b[33mpos_ratio\u001b[39m\u001b[33m'\u001b[39m]\n\u001b[32m---> \u001b[39m\u001b[32m46\u001b[39m hard_neg_ratio = phase_config[\u001b[33m'\u001b[39m\u001b[33mhard_neg_ratio\u001b[39m\u001b[33m'\u001b[39m] \u001b[38;5;28;01mif\u001b[39;00m phase_config \u001b[38;5;28;01melse\u001b[39;00m \u001b[43mconfig\u001b[49m\u001b[43m[\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43mhard_neg_ratio\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m]\u001b[49m\n\u001b[32m     47\u001b[39m neg_threshold = phase_config[\u001b[33m'\u001b[39m\u001b[33mneg_threshold\u001b[39m\u001b[33m'\u001b[39m] \u001b[38;5;28;01mif\u001b[39;00m phase_config \u001b[38;5;28;01melse\u001b[39;00m config[\u001b[33m'\u001b[39m\u001b[33mneg_tfidf_threshold\u001b[39m\u001b[33m'\u001b[39m]\n\u001b[32m     48\u001b[39m easy_neg_ratio = \u001b[32m1.0\u001b[39m - pos_ratio - hard_neg_ratio\n",
      "\u001b[31mKeyError\u001b[39m: 'hard_neg_ratio'"
     ]
    }
   ],
   "source": [
    "# Generate pairs for each split with reusable TF-IDF\n",
    "# Scale pair counts based on split sizes\n",
    "train_pair_count = int(CONFIG['num_pairs'] * 0.75)  # 75% for training\n",
    "eval_pair_count = int(CONFIG['num_pairs'] * 0.15)   # 15% for eval\n",
    "holdout_pair_count = int(CONFIG['num_pairs'] * 0.10) # 10% for holdout\n",
    "\n",
    "# Build TF-IDF once per split to reuse across phases/evals\n",
    "log(\"\\n\ud83e\udde0 Building reusable TF-IDF matrices (one per split)...\")\n",
    "tfidf_train = TFIDFSimilarityCalculator(train_df['text'].tolist())\n",
    "tfidf_eval = TFIDFSimilarityCalculator(eval_df['text'].tolist())\n",
    "tfidf_holdout = TFIDFSimilarityCalculator(holdout_df['text'].tolist())\n",
    "\n",
    "# Generate pairs using shared TF-IDF calculators\n",
    "train_examples = generate_training_pairs(train_df, train_pair_count, CONFIG, desc=\"Training\", tfidf_calc=tfidf_train)\n",
    "eval_examples = generate_training_pairs(eval_df, eval_pair_count, CONFIG, desc=\"Evaluation\", tfidf_calc=tfidf_eval)\n",
    "holdout_examples = generate_training_pairs(holdout_df, holdout_pair_count, CONFIG, desc=\"Holdout\", tfidf_calc=tfidf_holdout)\n",
    "\n",
    "# V2 NEW: Generate borderline test set for harder evaluation (reuse holdout TF-IDF)\n",
    "borderline_count = int(CONFIG['num_pairs'] * 0.05)  # 5% as borderline test\n",
    "borderline_examples = generate_borderline_pairs(holdout_df, borderline_count, CONFIG, desc=\"Borderline Test\", tfidf_calc=tfidf_holdout)\n",
    "\n",
    "log(f\"\\n\ud83d\udce6 Final Pair Counts:\")\n",
    "log(f\"   Train:      {len(train_examples):,}\")\n",
    "log(f\"   Eval:       {len(eval_examples):,}\")\n",
    "log(f\"   Holdout:    {len(holdout_examples):,}\")\n",
    "log(f\"   Borderline: {len(borderline_examples):,} (V2 NEW - harder test)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "530c4f9e",
   "metadata": {},
   "source": [
    "# 6. Model Training with LoRA + Multi-Loss\n",
    "\n",
    "Train `all-mpnet-base-v2` with LoRA adapters and combined loss function.\n",
    "\n",
    "## \u2728 NEW: LoRA/PEFT Integration\n",
    "\n",
    "**Why LoRA?**\n",
    "- **90%+ parameter reduction**: Only 3-5M trainable params vs 30-50M full fine-tune\n",
    "- **Faster training**: Less parameters = faster gradient updates\n",
    "- **Better generalization**: Prevents overfitting on smaller datasets\n",
    "- **Deployment flexibility**: Can merge adapters or serve separately\n",
    "\n",
    "**LoRA Configuration:**\n",
    "- **Rank (r)**: 16 (balances capacity vs efficiency)\n",
    "- **Alpha**: 32 (scaling factor, typically 2\u00d7r)\n",
    "- **Target modules**: `q_proj`, `v_proj` (attention query/value projections)\n",
    "- **Learning rate**: 1e-4 (lower than full fine-tune's 2e-5)\n",
    "\n",
    "## \u2728 NEW: Multi-Loss Training\n",
    "\n",
    "**Why combine MNRL + CosineSimilarity?**\n",
    "- **MultipleNegativesRankingLoss (90%)**: Primary loss for ranking quality\n",
    "  - In-batch negatives provide strong contrastive signal\n",
    "  - Optimizes for relative similarity ordering\n",
    "- **CosineSimilarityLoss (10%)**: Auxiliary loss for threshold calibration\n",
    "  - Calibrates absolute similarity scores\n",
    "  - Improves binary classification threshold selection\n",
    "  - Helps with F1/precision/recall optimization\n",
    "\n",
    "**V2 Curriculum Strategy:**\n",
    "- **Phase 1 (Epochs 1-2):** Easier pairs (25% hard negatives, threshold 0.15)\n",
    "- **Phase 2 (Epochs 3-4):** Harder pairs (55% hard negatives, threshold 0.10)\n",
    "\n",
    "This progressive difficulty helps the model learn basic patterns first, then refine on edge cases."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0a5cd19f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\ud83d\udd27 Loading base model: sentence-transformers/all-mpnet-base-v2\n",
      "\ud83c\udfaf Applying LoRA adapters...\n",
      "   Rank (r): 16\n",
      "   Alpha: 32\n",
      "   Target modules (resolved): ['dense']\n",
      "   Dropout: 0.1\n",
      "\u2705 LoRA Applied!\n",
      "   Trainable params: 1,499,136 (1.35%)\n",
      "   Total params: 110,985,600\n",
      "   Parameter reduction: 98.65%\n",
      "\u2705 Model loaded on cuda, max_seq_length=256\n",
      "\n",
      "\ud83d\udcca Preparing training data...\n",
      "   Train pairs (all): 33,216\n",
      "   Eval pairs (all):  7,480\n",
      "   Train balance: 6,966 pos (21.0%), 26,250 neg (79.0%)\n",
      "\ud83d\udd27 Using CosineSimilarityLoss (respects explicit labels)\n",
      "   Batch size: 16\n",
      "   Utilizes curated hard negatives: YES\n",
      "   Total training pairs: 33,216\n",
      "\n",
      "\ud83d\udcca Training Setup:\n",
      "   Batches per epoch: 2076\n",
      "   Total training steps: 8304\n",
      "   Warmup steps: 830\n",
      "   Curriculum learning: True\n",
      "\n",
      "\ud83d\udcca Training Setup:\n"
     ]
    }
   ],
   "source": [
    "from sentence_transformers import SentenceTransformer, losses\n",
    "from sentence_transformers.evaluation import SentenceEvaluator\n",
    "from torch.utils.data import DataLoader\n",
    "from scipy.stats import spearmanr, pearsonr\n",
    "from sklearn.metrics import roc_auc_score, average_precision_score\n",
    "from sklearn.model_selection import KFold\n",
    "from datetime import datetime\n",
    "import gc\n",
    "import torch.nn as nn\n",
    "import torch.nn.functional as F\n",
    "\n",
    "# --- Custom Evaluator ---\n",
    "class ITSMEvaluator(SentenceEvaluator):\n",
    "    \"\"\"Evaluator for ITSM ticket similarity.\"\"\"\n",
    "    \n",
    "    def __init__(self, examples, batch_size=16, name=\"\"):\n",
    "        self.examples = examples\n",
    "        self.batch_size = batch_size\n",
    "        self.name = name\n",
    "        \n",
    "        self.texts1 = [ex.texts[0] for ex in examples]\n",
    "        self.texts2 = [ex.texts[1] for ex in examples]\n",
    "        self.labels = np.array([ex.label for ex in examples])\n",
    "        \n",
    "        self.csv_file = f\"{name}_eval_results.csv\"\n",
    "        self.csv_headers = [\"epoch\", \"steps\", \"spearman\", \"pearson\", \"roc_auc\", \"pr_auc\"]\n",
    "    \n",
    "    def __call__(self, model, output_path=None, epoch=-1, steps=-1):\n",
    "        model.eval()\n",
    "        \n",
    "        # Encode pairs\n",
    "        emb1 = model.encode(self.texts1, batch_size=self.batch_size, \n",
    "                          show_progress_bar=False, convert_to_numpy=True)\n",
    "        emb2 = model.encode(self.texts2, batch_size=self.batch_size, \n",
    "                          show_progress_bar=False, convert_to_numpy=True)\n",
    "        \n",
    "        # Compute cosine similarity\n",
    "        scores = np.sum(emb1 * emb2, axis=1) / (\n",
    "            np.linalg.norm(emb1, axis=1) * np.linalg.norm(emb2, axis=1) + 1e-8\n",
    "        )\n",
    "        \n",
    "        # Compute metrics\n",
    "        spearman, _ = spearmanr(self.labels, scores)\n",
    "        pearson, _ = pearsonr(self.labels, scores)\n",
    "        \n",
    "        try:\n",
    "            roc_auc = roc_auc_score(self.labels, scores)\n",
    "            pr_auc = average_precision_score(self.labels, scores)\n",
    "        except ValueError:\n",
    "            roc_auc, pr_auc = 0.0, 0.0\n",
    "        \n",
    "        log(f\"  [{self.name}] Epoch {epoch}: Spearman={spearman:.4f}, ROC-AUC={roc_auc:.4f}, PR-AUC={pr_auc:.4f}\")\n",
    "        \n",
    "        # Save to CSV\n",
    "        if output_path:\n",
    "            csv_path = Path(output_path) / self.csv_file\n",
    "            if not csv_path.exists():\n",
    "                with open(csv_path, 'w') as f:\n",
    "                    f.write(','.join(self.csv_headers) + '\\n')\n",
    "            with open(csv_path, 'a') as f:\n",
    "                f.write(f\"{epoch},{steps},{spearman},{pearson},{roc_auc},{pr_auc}\\n\")\n",
    "        \n",
    "        return spearman  # Primary metric\n",
    "\n",
    "\n",
    "# --- Model Initialization with LoRA/PEFT ---\n",
    "def init_model_with_lora(config, device):\n",
    "    \"\"\"Initialize model with optional LoRA/PEFT adapters.\"\"\"\n",
    "    # Clear GPU memory\n",
    "    if device == 'cuda':\n",
    "        torch.cuda.empty_cache()\n",
    "    elif device == 'mps':\n",
    "        torch.mps.empty_cache()\n",
    "    gc.collect()\n",
    "    \n",
    "    log(f\"\ud83d\udd27 Loading base model: {config['model_name']}\")\n",
    "    model = SentenceTransformer(config['model_name'], device=device)\n",
    "    # Cap max sequence length to reduce memory footprint\n",
    "    model.max_seq_length = min(config['max_seq_length'], 256)\n",
    "    \n",
    "    # Apply LoRA if enabled\n",
    "    if config['use_lora']:\n",
    "        from peft import LoraConfig, get_peft_model, TaskType\n",
    "        \n",
    "        # Inspect module names to find viable targets\n",
    "        base_model = model[0].auto_model\n",
    "        linear_names = [name for name, module in base_model.named_modules() if isinstance(module, nn.Linear)]\n",
    "        configured_targets = config['lora_target_modules']\n",
    "        resolved_targets = [t for t in configured_targets if any(t in n for n in linear_names)]\n",
    "        \n",
    "        if not resolved_targets:\n",
    "            # Fallback heuristics for BERT/MPNet-like models\n",
    "            priority = ['q_proj', 'k_proj', 'v_proj', 'query', 'key', 'value', 'dense']\n",
    "            resolved_targets = [p for p in priority if any(p in n for n in linear_names)]\n",
    "        \n",
    "        if not resolved_targets:\n",
    "            log(\"\u274c Could not find matching target modules for LoRA. Available linear submodules include:\")\n",
    "            sample = linear_names[:50]\n",
    "            for n in sample:\n",
    "                log(f\"   - {n}\")\n",
    "            raise ValueError(\"LoRA target_modules could not be resolved; please adjust CONFIG['lora_target_modules'].\")\n",
    "        \n",
    "        log(f\"\ud83c\udfaf Applying LoRA adapters...\")\n",
    "        log(f\"   Rank (r): {config['lora_r']}\")\n",
    "        log(f\"   Alpha: {config['lora_alpha']}\")\n",
    "        log(f\"   Target modules (resolved): {resolved_targets}\")\n",
    "        log(f\"   Dropout: {config['lora_dropout']}\")\n",
    "        \n",
    "        lora_config = LoraConfig(\n",
    "            r=config['lora_r'],\n",
    "            lora_alpha=config['lora_alpha'],\n",
    "            target_modules=resolved_targets,\n",
    "            lora_dropout=config['lora_dropout'],\n",
    "            bias=\"none\",\n",
    "            task_type=TaskType.FEATURE_EXTRACTION,\n",
    "        )\n",
    "        \n",
    "        # Apply PEFT wrapper\n",
    "        peft_model = get_peft_model(base_model, lora_config)\n",
    "        model[0].auto_model = peft_model\n",
    "        \n",
    "        # Enable gradient checkpointing to reduce memory\n",
    "        try:\n",
    "            model[0].auto_model.gradient_checkpointing_enable()\n",
    "            log(\"\ud83e\udde0 Gradient checkpointing enabled\")\n",
    "        except Exception:\n",
    "            pass\n",
    "        \n",
    "        # Print trainable parameters\n",
    "        trainable_params = sum(p.numel() for p in peft_model.parameters() if p.requires_grad)\n",
    "        total_params = sum(p.numel() for p in peft_model.parameters())\n",
    "        trainable_pct = 100 * trainable_params / total_params\n",
    "        \n",
    "        log(f\"\u2705 LoRA Applied!\")\n",
    "        log(f\"   Trainable params: {trainable_params:,} ({trainable_pct:.2f}%)\")\n",
    "        log(f\"   Total params: {total_params:,}\")\n",
    "        log(f\"   Parameter reduction: {100 - trainable_pct:.2f}%\")\n",
    "    else:\n",
    "        log(f\"\u2139\ufe0f Full fine-tuning (no LoRA)\")\n",
    "        total_params = sum(p.numel() for p in model.parameters())\n",
    "        log(f\"   Total params: {total_params:,}\")\n",
    "    \n",
    "    log(f\"\u2705 Model loaded on {device}, max_seq_length={model.max_seq_length}\")\n",
    "    \n",
    "    return model\n",
    "\n",
    "\n",
    "# --- V2: Cross-Validated Threshold Selection ---\n",
    "def get_cv_threshold(examples, model, n_folds=5):\n",
    "    \"\"\"\n",
    "    V2 NEW: Use k-fold cross-validation to find robust threshold.\n",
    "    \n",
    "    Returns the average best threshold across folds.\n",
    "    \"\"\"\n",
    "    from sklearn.metrics import precision_recall_curve, f1_score\n",
    "    \n",
    "    texts1 = [ex.texts[0] for ex in examples]\n",
    "    texts2 = [ex.texts[1] for ex in examples]\n",
    "    labels = np.array([ex.label for ex in examples])\n",
    "    \n",
    "    # Encode all pairs\n",
    "    emb1 = model.encode(texts1, batch_size=CONFIG['batch_size'], show_progress_bar=False)\n",
    "    emb2 = model.encode(texts2, batch_size=CONFIG['batch_size'], show_progress_bar=False)\n",
    "    scores = np.sum(emb1 * emb2, axis=1) / (np.linalg.norm(emb1, axis=1) * np.linalg.norm(emb2, axis=1) + 1e-8)\n",
    "    \n",
    "    kf = KFold(n_splits=n_folds, shuffle=True, random_state=CONFIG['seed'])\n",
    "    best_thresholds = []\n",
    "    \n",
    "    for fold, (train_idx, val_idx) in enumerate(kf.split(scores)):\n",
    "        val_scores = scores[val_idx]\n",
    "        val_labels = labels[val_idx]\n",
    "        \n",
    "        precision, recall, thresholds = precision_recall_curve(val_labels, val_scores)\n",
    "        f1_scores = 2 * (precision * recall) / (precision + recall + 1e-10)\n",
    "        best_idx = np.argmax(f1_scores)\n",
    "        best_threshold = thresholds[best_idx-1] if 0 < best_idx < len(thresholds)+1 else 0.5\n",
    "        best_thresholds.append(best_threshold)\n",
    "    \n",
    "    avg_threshold = np.mean(best_thresholds)\n",
    "    std_threshold = np.std(best_thresholds)\n",
    "    \n",
    "    log(f\"\ud83d\udcca CV Threshold ({n_folds}-fold): {avg_threshold:.4f} \u00b1 {std_threshold:.4f}\")\n",
    "    log(f\"   Per-fold thresholds: {[f'{t:.3f}' for t in best_thresholds]}\")\n",
    "    \n",
    "    return avg_threshold, std_threshold\n",
    "\n",
    "\n",
    "# --- Multi-Loss Wrapper ---\n",
    "class CombinedLoss(nn.Module):\n",
    "    \"\"\"Combines MultipleNegativesRankingLoss + CosineSimilarityLoss with a shared forward pass.\"\"\"\n",
    "    \n",
    "    def __init__(self, model, mnrl_weight=0.9, cosine_weight=0.1, mnrl_scale=20.0):\n",
    "        super().__init__()\n",
    "        self.model = model\n",
    "        self.cosine = losses.CosineSimilarityLoss(model)\n",
    "        self.mnrl_weight = mnrl_weight\n",
    "        self.cosine_weight = cosine_weight\n",
    "        self.mnrl_scale = mnrl_scale\n",
    "        self.ce = nn.CrossEntropyLoss()\n",
    "        \n",
    "        log(f\"\ud83d\udd00 Combined Loss Initialized:\")\n",
    "        log(f\"   MNRL weight: {mnrl_weight:.2f}\")\n",
    "        log(f\"   Cosine weight: {cosine_weight:.2f}\")\n",
    "        log(f\"   MNRL scale: {mnrl_scale:.1f}\")\n",
    "    \n",
    "    def forward(self, sentence_features, labels):\n",
    "        \"\"\"Single forward pass to compute embeddings, then both losses.\"\"\"\n",
    "        embeddings = [self.model(sentence_feature)[\"sentence_embedding\"] for sentence_feature in sentence_features]\n",
    "        # Normalize for cosine similarity consistency\n",
    "        emb1 = F.normalize(embeddings[0], p=2, dim=1)\n",
    "        emb2 = F.normalize(embeddings[1], p=2, dim=1)\n",
    "        \n",
    "        # MultipleNegativesRankingLoss (manual computation)\n",
    "        sim_matrix = torch.matmul(emb1, emb2.transpose(0, 1)) * self.mnrl_scale\n",
    "        mnrl_labels = torch.arange(sim_matrix.size(0), device=sim_matrix.device)\n",
    "        mnrl_loss = self.ce(sim_matrix, mnrl_labels)\n",
    "        \n",
    "        # CosineSimilarityLoss using precomputed embeddings\n",
    "        cosine_loss = self.cosine.compute_loss_from_embeddings([emb1, emb2], labels)\n",
    "        \n",
    "        return self.mnrl_weight * mnrl_loss + self.cosine_weight * cosine_loss\n",
    "\n",
    "\n",
    "# Initialize model\n",
    "model = init_model_with_lora(CONFIG, DEVICE)\n",
    "\n",
    "# \u2728 IMPROVEMENT: Use ALL training pairs (positives + negatives) instead of filtering\n",
    "log(f\"\\n\ud83d\udcca Preparing training data...\")\n",
    "log(f\"   Train pairs (all): {len(train_examples):,}\")\n",
    "log(f\"   Eval pairs (all):  {len(eval_examples):,}\")\n",
    "pos_count = sum(1 for ex in train_examples if ex.label == 1.0)\n",
    "neg_count = len(train_examples) - pos_count\n",
    "log(f\"   Train balance: {pos_count:,} pos ({pos_count/len(train_examples)*100:.1f}%), {neg_count:,} neg ({neg_count/len(train_examples)*100:.1f}%)\")\n",
    "\n",
    "# \u2728 IMPROVEMENT: Increase batch size from 2 to 16 for better gradient estimates\n",
    "_train_batch = 16\n",
    "train_dataloader = DataLoader(\n",
    "    train_examples,  # Use ALL pairs, not just positives\n",
    "    shuffle=True,\n",
    "    batch_size=_train_batch,\n",
    "    num_workers=0,\n",
    "    pin_memory=(DEVICE in ['cuda', 'mps'])\n",
    ")\n",
    "# \u2728 IMPROVEMENT: Use CosineSimilarityLoss to respect explicit positive/negative labels\n",
    "# This allows us to utilize all curated hard negative pairs instead of discarding them\n",
    "train_loss = losses.CosineSimilarityLoss(model)\n",
    "log(f\"\ud83d\udd27 Using CosineSimilarityLoss (respects explicit labels)\")\n",
    "log(f\"   Batch size: {_train_batch}\")\n",
    "log(f\"   Utilizes curated hard negatives: YES\")\n",
    "log(f\"   Total training pairs: {len(train_examples):,}\")\n",
    "\n",
    "# Evaluator\n",
    "_evaluator_batch = _train_batch\n",
    "_evaluator_examples = eval_examples\n",
    "_evaluator = ITSMEvaluator(_evaluator_examples, batch_size=_evaluator_batch, name=\"eval\")\n",
    "evaluator = _evaluator\n",
    "\n",
    "log(f\"\\n\ud83d\udcca Training Setup:\")\n",
    "log(f\"   Batches per epoch: {len(train_dataloader)}\")\n",
    "log(f\"   Total training steps: {len(train_dataloader) * CONFIG['epochs']}\")\n",
    "log(f\"   Warmup steps: {int(len(train_dataloader) * CONFIG['epochs'] * CONFIG['warmup_ratio'])}\")\n",
    "log(f\"   Curriculum learning: {CONFIG['use_curriculum']}\")\n",
    "log(f\"\\n\ud83d\udcca Training Setup:\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a9e2fb72",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\ud83d\ude80 Starting Training (V2)...\n",
      "   Output: models\\real_servicenow_finetuned_mpnet_lora\\real_servicenow_v2_20251224_0449\n",
      "   Epochs: 4\n",
      "   Device: cuda\n",
      "\n",
      "\ud83d\udcda CURRICULUM LEARNING ENABLED\n",
      "\n",
      "============================================================\n",
      "\ud83d\udcda Phase 1: 2 epochs\n",
      "   Hard neg ratio: 25%\n",
      "   Neg threshold: 0.15\n",
      "============================================================\n",
      "\n",
      "\ud83c\udfaf Generating 33,216 pairs for Phase 1:\n",
      "   Target: 9,964 positives (30%), 8,304 hard neg (25%), 14,948 easy neg\n",
      "   Neg TF-IDF threshold: 0.15\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Positives (high TF-IDF):  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 6246/9964 [02:02<01:13, 50.79it/s]\n",
      "Hard Negatives (same cat, TF-IDF<0.15): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 8304/8304 [00:03<00:00, 2269.48it/s]\n",
      "Easy Negatives (cross-cat): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 14948/14948 [00:04<00:00, 3081.04it/s]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u2705 Generated 29,498 pairs:\n",
      "   Positives: 6,246 (21.2%)\n",
      "   Hard Neg:  8,304 (28.2%)\n",
      "   Easy Neg:  14,948 (50.7%)\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Using the `WANDB_DISABLED` environment variable is deprecated and will be removed in v5. Use the --report_to flag to control the integrations used for logging result (for instance --report_to none).\n",
      "Using the `WANDB_DISABLED` environment variable is deprecated and will be removed in v5. Use the --report_to flag to control the integrations used for logging result (for instance --report_to none).\n",
      "                                                                     \r"
     ]
    },
    {
     "data": {
      "text/html": [
       "\n",
       "    <div>\n",
       "      \n",
       "      <progress value='3688' max='3688' style='width:300px; height:20px; vertical-align: middle;'></progress>\n",
       "      [3688/3688 13:57, Epoch 2/2]\n",
       "    </div>\n",
       "    <table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       " <tr style=\"text-align: left;\">\n",
       "      <th>Step</th>\n",
       "      <th>Training Loss</th>\n",
       "      <th>Validation Loss</th>\n",
       "      <th>Evaluator</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <td>1038</td>\n",
       "      <td>0.026500</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.785443</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>1844</td>\n",
       "      <td>0.021200</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.789939</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>2076</td>\n",
       "      <td>0.017800</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.788961</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>3114</td>\n",
       "      <td>0.015500</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.789337</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>3688</td>\n",
       "      <td>0.013800</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.789232</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table><p>"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  [eval] Epoch 0.5629067245119306: Spearman=0.7854, ROC-AUC=0.9957, PR-AUC=0.9931\n",
      "  [eval] Epoch 1.0: Spearman=0.7899, ROC-AUC=0.9985, PR-AUC=0.9970\n",
      "  [eval] Epoch 1.1258134490238612: Spearman=0.7890, ROC-AUC=0.9979, PR-AUC=0.9959\n",
      "  [eval] Epoch 1.6887201735357917: Spearman=0.7893, ROC-AUC=0.9981, PR-AUC=0.9964\n",
      "  [eval] Epoch 2.0: Spearman=0.7892, ROC-AUC=0.9981, PR-AUC=0.9964\n",
      "\u2705 Phase 1 complete!\n",
      "\n",
      "============================================================\n",
      "\ud83d\udcda Phase 2: 2 epochs\n",
      "   Hard neg ratio: 55%\n",
      "   Neg threshold: 0.1\n",
      "============================================================\n",
      "\n",
      "\ud83c\udfaf Generating 33,216 pairs for Phase 2:\n",
      "   Target: 9,964 positives (30%), 18,268 hard neg (55%), 4,984 easy neg\n",
      "   Neg TF-IDF threshold: 0.1\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Positives (high TF-IDF):  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 6191/9964 [01:59<01:12, 52.01it/s]\n",
      "Hard Negatives (same cat, TF-IDF<0.1): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18268/18268 [00:09<00:00, 1958.79it/s]\n",
      "Easy Negatives (cross-cat): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4984/4984 [00:01<00:00, 3198.22it/s]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u2705 Generated 29,443 pairs:\n",
      "   Positives: 6,191 (21.0%)\n",
      "   Hard Neg:  18,268 (62.0%)\n",
      "   Easy Neg:  4,984 (16.9%)\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Using the `WANDB_DISABLED` environment variable is deprecated and will be removed in v5. Use the --report_to flag to control the integrations used for logging result (for instance --report_to none).\n",
      "Using the `WANDB_DISABLED` environment variable is deprecated and will be removed in v5. Use the --report_to flag to control the integrations used for logging result (for instance --report_to none).\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "\n",
       "    <div>\n",
       "      \n",
       "      <progress value='3682' max='3682' style='width:300px; height:20px; vertical-align: middle;'></progress>\n",
       "      [3682/3682 13:38, Epoch 2/2]\n",
       "    </div>\n",
       "    <table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       " <tr style=\"text-align: left;\">\n",
       "      <th>Step</th>\n",
       "      <th>Training Loss</th>\n",
       "      <th>Validation Loss</th>\n",
       "      <th>Evaluator</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <td>1038</td>\n",
       "      <td>0.008400</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.791209</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>1841</td>\n",
       "      <td>0.008800</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.790982</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>2076</td>\n",
       "      <td>0.006000</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.790131</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>3114</td>\n",
       "      <td>0.006200</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.790372</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <td>3682</td>\n",
       "      <td>0.005500</td>\n",
       "      <td>No log</td>\n",
       "      <td>0.790516</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table><p>"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  [eval] Epoch 0.5638240086909289: Spearman=0.7912, ROC-AUC=0.9993, PR-AUC=0.9987\n",
      "  [eval] Epoch 1.0: Spearman=0.7910, ROC-AUC=0.9992, PR-AUC=0.9983\n",
      "  [eval] Epoch 1.1276480173818577: Spearman=0.7901, ROC-AUC=0.9986, PR-AUC=0.9975\n",
      "  [eval] Epoch 1.6914720260727867: Spearman=0.7904, ROC-AUC=0.9988, PR-AUC=0.9981\n",
      "  [eval] Epoch 2.0: Spearman=0.7905, ROC-AUC=0.9989, PR-AUC=0.9982\n",
      "\u2705 Phase 2 complete!\n",
      "\n",
      "\u2705 Training complete!\n",
      "\n",
      "\ud83d\udcca Loading best model for final evaluation...\n"
     ]
    }
   ],
   "source": [
    "# --- Training Execution (V2: with Curriculum Learning) ---\n",
    "timestamp = datetime.now().strftime(\"%Y%m%d_%H%M\")\n",
    "save_path = Path(CONFIG['output_dir']) / f\"real_servicenow_v2_{timestamp}\"\n",
    "save_path.mkdir(parents=True, exist_ok=True)\n",
    "\n",
    "log(f\"\\n\ud83d\ude80 Starting Training (V2)...\")\n",
    "log(f\"   Output: {save_path}\")\n",
    "log(f\"   Epochs: {CONFIG['epochs']}\")\n",
    "log(f\"   Device: {DEVICE}\")\n",
    "\n",
    "# Calculate warmup steps\n",
    "total_steps = len(train_dataloader) * CONFIG['epochs']\n",
    "warmup_steps = int(total_steps * CONFIG['warmup_ratio'])\n",
    "eval_steps = max(100, len(train_dataloader) // 2)  # Evaluate twice per epoch\n",
    "use_amp = DEVICE != 'cuda'  # Flip: CUDA stays fp32, CPU/MPS use fp16 autocast when available\n",
    "\n",
    "try:\n",
    "    if CONFIG['use_curriculum']:\n",
    "        # V2: Curriculum Learning - train in phases\n",
    "        log(\"\\n\ud83d\udcda CURRICULUM LEARNING ENABLED\")\n",
    "        \n",
    "        for phase_idx, phase in enumerate(CONFIG['curriculum_phases']):\n",
    "            log(f\"\\n{'='*60}\")\n",
    "            log(f\"\ud83d\udcda Phase {phase_idx + 1}: {phase['epochs']} epochs\")\n",
    "            log(f\"   Hard neg ratio: {phase['hard_neg_ratio']*100:.0f}%\")\n",
    "            log(f\"   Neg threshold: {phase['neg_threshold']}\")\n",
    "            log(f\"{'='*60}\")\n",
    "            \n",
    "            # Regenerate training pairs for this phase (reuse train TF-IDF)\n",
    "            phase_train_examples = generate_training_pairs(\n",
    "                train_df, \n",
    "                len(train_examples),  # \u2728 Use all pairs count, not just positives\n",
    "                CONFIG, \n",
    "                desc=f\"Phase {phase_idx+1}\",\n",
    "                phase_config=phase,\n",
    "                tfidf_calc=tfidf_train\n",
    "            )\n",
    "            # \u2728 IMPROVEMENT: Use all pairs (pos + neg), not just positives\n",
    "            \n",
    "            phase_batch_size = 16  # \u2728 Increased from 2 to 16\n",
    "            phase_dataloader = DataLoader(\n",
    "                phase_train_examples,  # Use all pairs\n",
    "                shuffle=True,\n",
    "                batch_size=phase_batch_size,\n",
    "                num_workers=0,\n",
    "                pin_memory=(DEVICE in ['cuda', 'mps'])\n",
    "            )\n",
    "            \n",
    "            phase_warmup = int(len(phase_dataloader) * phase['epochs'] * CONFIG['warmup_ratio'])\n",
    "            \n",
    "            # Extra cleanup before each phase to avoid fragmentation\n",
    "            try:\n",
    "                if DEVICE == 'cuda':\n",
    "                    torch.cuda.empty_cache()\n",
    "            except Exception:\n",
    "                pass\n",
    "            \n",
    "            model.fit(\n",
    "                train_objectives=[(phase_dataloader, train_loss)],\n",
    "                evaluator=evaluator,\n",
    "                epochs=phase['epochs'],\n",
    "                warmup_steps=phase_warmup,\n",
    "                optimizer_params={'lr': 2e-5},  # \u2728 Reduced from 1e-4 to 2e-5 for LoRA\n",
    "                output_path=str(save_path),\n",
    "                evaluation_steps=eval_steps,\n",
    "                save_best_model=True,\n",
    "                show_progress_bar=True,\n",
    "                use_amp=use_amp,\n",
    "            )\n",
    "            \n",
    "            log(f\"\u2705 Phase {phase_idx + 1} complete!\")\n",
    "    else:\n",
    "        # Standard training (no curriculum)\n",
    "        try:\n",
    "            if DEVICE == 'cuda':\n",
    "                torch.cuda.empty_cache()\n",
    "        except Exception:\n",
    "            pass\n",
    "        \n",
    "        model.fit(\n",
    "            train_objectives=[(train_dataloader, train_loss)],\n",
    "            evaluator=evaluator,\n",
    "            epochs=CONFIG['epochs'],\n",
    "            warmup_steps=warmup_steps,\n",
    "            optimizer_params={'lr': 2e-5},  # \u2728 Reduced from 1e-4 to 2e-5 for LoRA\n",
    "            output_path=str(save_path),\n",
    "            evaluation_steps=eval_steps,\n",
    "            save_best_model=True,\n",
    "            show_progress_bar=True,\n",
    "            use_amp=use_amp,\n",
    "        )\n",
    "    \n",
    "    log(\"\\n\u2705 Training complete!\")\n",
    "    \n",
    "except RuntimeError as e:\n",
    "    err_msg = str(e).lower()\n",
    "    if (\"out of memory\" in err_msg) or (\"no kernel image\" in err_msg) or (\"not compatible\" in err_msg):\n",
    "        log(f\"\u274c Runtime Error: {e}\")\n",
    "        log(\"\ud83d\udca1 Falling back to CPU/MPS to continue training...\")\n",
    "        # Cleanup GPU\n",
    "        try:\n",
    "            del model\n",
    "        except Exception:\n",
    "            pass\n",
    "        try:\n",
    "            if torch.cuda.is_available():\n",
    "                torch.cuda.empty_cache()\n",
    "        except Exception:\n",
    "            pass\n",
    "        gc.collect()\n",
    "        \n",
    "        # Fallback device\n",
    "        if hasattr(torch.backends, 'mps') and torch.backends.mps.is_available():\n",
    "            DEVICE = 'mps'\n",
    "            log(\"\ud83c\udf4e Switching to MPS\")\n",
    "        else:\n",
    "            DEVICE = 'cpu'\n",
    "            log(\"\ud83e\udde0 Switching to CPU\")\n",
    "        \n",
    "        # Re-init model and loss on fallback device\n",
    "        model = init_model_with_lora(CONFIG, DEVICE)\n",
    "        # Always use CosineSimilarityLoss with all pairs\n",
    "        train_loss = losses.CosineSimilarityLoss(model)\n",
    "        \n",
    "        # Recreate dataloaders with safe batch size on fallback device\n",
    "        safe_batch = 8 if DEVICE != 'cuda' else 16\n",
    "        fallback_use_amp = DEVICE != 'cuda'\n",
    "        if CONFIG['use_curriculum']:\n",
    "            for phase_idx, phase in enumerate(CONFIG['curriculum_phases']):\n",
    "                log(f\"\\n[Fallback] Phase {phase_idx + 1}: {phase['epochs']} epochs\")\n",
    "                phase_train_examples = generate_training_pairs(\n",
    "                    train_df,\n",
    "                    len(train_examples),\n",
    "                    CONFIG,\n",
    "                    desc=f\"Phase {phase_idx+1}\",\n",
    "                    phase_config=phase,\n",
    "                    tfidf_calc=tfidf_train\n",
    "                )\n",
    "                phase_dataloader = DataLoader(\n",
    "                    phase_train_examples,\n",
    "                    shuffle=True,\n",
    "                    batch_size=safe_batch,\n",
    "                    num_workers=0,\n",
    "                    pin_memory=(DEVICE in ['cuda', 'mps'])\n",
    "                )\n",
    "                phase_warmup = int(len(phase_dataloader) * phase['epochs'] * CONFIG['warmup_ratio'])\n",
    "                model.fit(\n",
    "                    train_objectives=[(phase_dataloader, train_loss)],\n",
    "                    evaluator=evaluator,\n",
    "                    epochs=phase['epochs'],\n",
    "                    warmup_steps=phase_warmup,\n",
    "                    optimizer_params={'lr': CONFIG['lr']},\n",
    "                    output_path=str(save_path),\n",
    "                    evaluation_steps=eval_steps,\n",
    "                    save_best_model=True,\n",
    "                    show_progress_bar=True,\n",
    "                    use_amp=fallback_use_amp,\n",
    "                )\n",
    "        else:\n",
    "            model.fit(\n",
    "                train_objectives=[(train_dataloader, train_loss)],\n",
    "                evaluator=evaluator,\n",
    "                epochs=CONFIG['epochs'],\n",
    "                warmup_steps=warmup_steps,\n",
    "                optimizer_params={'lr': CONFIG['lr']},\n",
    "                output_path=str(save_path),\n",
    "                evaluation_steps=eval_steps,\n",
    "                save_best_model=True,\n",
    "                show_progress_bar=True,\n",
    "                use_amp=fallback_use_amp,\n",
    "            )\n",
    "        \n",
    "        log(\"\\n\u2705 Training complete on fallback device!\")\n",
    "    else:\n",
    "        raise\n",
    "\n",
    "# Reload best model\n",
    "log(\"\\n\ud83d\udcca Loading best model for final evaluation...\")\n",
    "best_model = SentenceTransformer(str(save_path), device=DEVICE)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "85294299",
   "metadata": {},
   "source": [
    "# 7. Evaluation & Visualization"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a013b458",
   "metadata": {},
   "source": [
    "# 6.5 Score Distribution Diagnostic (V2: Verify Model Learned Separation)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b4ce86a2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\ud83d\udd0d SCORE DISTRIBUTION DIAGNOSTIC\n",
      "============================================================\n",
      "Analyzing 250 positive + 250 negative pairs...\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Positive pairs: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:14<00:00, 17.05it/s]\n",
      "Negative pairs: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 250/250 [00:15<00:00, 16.46it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\ud83d\udcca SCORE STATISTICS:\n",
      "   Positive pairs: mean=0.9399, std=0.1192, range=[0.3341, 0.9999]\n",
      "   Negative pairs: mean=0.0148, std=0.0622, range=[-0.1659, 0.3557]\n",
      "   Separability (\u0394): 0.9251\n",
      "\n",
      "\ud83d\udca1 INTERPRETATION:\n",
      "   \u2705 EXCELLENT: Strong separation (\u0394=0.9251 >= 0.15)\n",
      "      Model clearly distinguishes positive from negative pairs\n",
      "\n",
      "\ud83d\udcca DISTRIBUTION OVERLAP:\n",
      "   Negatives scoring > 0.5: 0/250 (0.0%)\n",
      "============================================================\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "# SCORE DISTRIBUTION DIAGNOSTIC (V2)\n",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "# This validates that the model learned to separate positive/negative pairs\n",
    "\n",
    "log(\"\\n\ud83d\udd0d SCORE DISTRIBUTION DIAGNOSTIC\")\n",
    "log(\"=\"*60)\n",
    "\n",
    "# Sample from eval set\n",
    "sample_size = min(500, len(eval_examples))\n",
    "sample_pos = [ex for ex in eval_examples if ex.label == 1.0][:sample_size//2]\n",
    "sample_neg = [ex for ex in eval_examples if ex.label == 0.0][:sample_size//2]\n",
    "\n",
    "log(f\"Analyzing {len(sample_pos)} positive + {len(sample_neg)} negative pairs...\")\n",
    "\n",
    "# Compute scores for positive pairs\n",
    "pos_scores = []\n",
    "for ex in tqdm(sample_pos, desc=\"Positive pairs\"):\n",
    "    emb1 = best_model.encode([ex.texts[0]], show_progress_bar=False)[0]\n",
    "    emb2 = best_model.encode([ex.texts[1]], show_progress_bar=False)[0]\n",
    "    score = np.dot(emb1, emb2) / (np.linalg.norm(emb1) * np.linalg.norm(emb2) + 1e-8)\n",
    "    pos_scores.append(score)\n",
    "\n",
    "# Compute scores for negative pairs\n",
    "neg_scores = []\n",
    "for ex in tqdm(sample_neg, desc=\"Negative pairs\"):\n",
    "    emb1 = best_model.encode([ex.texts[0]], show_progress_bar=False)[0]\n",
    "    emb2 = best_model.encode([ex.texts[1]], show_progress_bar=False)[0]\n",
    "    score = np.dot(emb1, emb2) / (np.linalg.norm(emb1) * np.linalg.norm(emb2) + 1e-8)\n",
    "    neg_scores.append(score)\n",
    "\n",
    "# Statistics\n",
    "pos_mean, pos_std = np.mean(pos_scores), np.std(pos_scores)\n",
    "neg_mean, neg_std = np.mean(neg_scores), np.std(neg_scores)\n",
    "separability = pos_mean - neg_mean\n",
    "\n",
    "log(f\"\\n\ud83d\udcca SCORE STATISTICS:\")\n",
    "log(f\"   Positive pairs: mean={pos_mean:.4f}, std={pos_std:.4f}, range=[{min(pos_scores):.4f}, {max(pos_scores):.4f}]\")\n",
    "log(f\"   Negative pairs: mean={neg_mean:.4f}, std={neg_std:.4f}, range=[{min(neg_scores):.4f}, {max(neg_scores):.4f}]\")\n",
    "log(f\"   Separability (\u0394): {separability:.4f}\")\n",
    "\n",
    "# Interpretation\n",
    "log(f\"\\n\ud83d\udca1 INTERPRETATION:\")\n",
    "if separability >= 0.15:\n",
    "    log(f\"   \u2705 EXCELLENT: Strong separation (\u0394={separability:.4f} >= 0.15)\")\n",
    "    log(f\"      Model clearly distinguishes positive from negative pairs\")\n",
    "elif separability >= 0.08:\n",
    "    log(f\"   \u2713 GOOD: Moderate separation (\u0394={separability:.4f} >= 0.08)\")\n",
    "    log(f\"      Model shows useful discrimination\")\n",
    "elif separability >= 0.03:\n",
    "    log(f\"   \u26a0\ufe0f  WEAK: Minimal separation (\u0394={separability:.4f} >= 0.03)\")\n",
    "    log(f\"      Model barely learned to discriminate\")\n",
    "else:\n",
    "    log(f\"   \u274c FAILURE: No separation (\u0394={separability:.4f} < 0.03)\")\n",
    "    log(f\"      Model produces similar scores for both positive and negative pairs!\")\n",
    "    log(f\"      Training likely failed - check batch size, loss function, or data quality\")\n",
    "\n",
    "# Distribution overlap check\n",
    "overlap_threshold = 0.5\n",
    "overlap_count = sum(1 for s in neg_scores if s > overlap_threshold)\n",
    "log(f\"\\n\ud83d\udcca DISTRIBUTION OVERLAP:\")\n",
    "log(f\"   Negatives scoring > {overlap_threshold}: {overlap_count}/{len(neg_scores)} ({overlap_count/len(neg_scores)*100:.1f}%)\")\n",
    "if overlap_count / len(neg_scores) > 0.3:\n",
    "    log(f\"   \u26a0\ufe0f  WARNING: High overlap - many negatives score like positives\")\n",
    "\n",
    "log(\"=\"*60)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9d094e89",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "============================================================\n",
      "\ud83d\udcc8 CROSS-VALIDATED THRESHOLD SELECTION (V2)\n",
      "============================================================\n",
      "\ud83d\udcca CV Threshold (5-fold): 0.3228 \u00b1 0.0634\n",
      "   Per-fold thresholds: ['0.432', '0.331', '0.236', '0.298', '0.317']\n",
      "\n",
      "============================================================\n",
      "\ud83d\udcc8 FINAL EVALUATION\n",
      "============================================================\n",
      "\u23f3 Encoding 7480 pairs for Eval Set...\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Batches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 468/468 [00:14<00:00, 32.97it/s]\n",
      "Batches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 468/468 [00:14<00:00, 33.16it/s]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\ud83d\udcca Eval Set Results:\n",
      "   Spearman:  0.7912\n",
      "   Pearson:   0.9744\n",
      "   ROC-AUC:   0.9993\n",
      "   PR-AUC:    0.9987\n",
      "   Best Threshold: 0.323\n",
      "   F1 @ best: 0.9844\n",
      "   Precision: 0.9787\n",
      "   Recall:    0.9901\n",
      "   Accuracy:  0.9906\n",
      "\u23f3 Encoding 5000 pairs for Holdout Set...\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Batches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:09<00:00, 32.80it/s]\n",
      "Batches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 313/313 [00:09<00:00, 32.77it/s]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\ud83d\udcca Holdout Set Results:\n",
      "   Spearman:  0.7926\n",
      "   Pearson:   0.9706\n",
      "   ROC-AUC:   0.9993\n",
      "   PR-AUC:    0.9985\n",
      "   Best Threshold: 0.281\n",
      "   F1 @ best: 0.9814\n",
      "   Precision: 0.9781\n",
      "   Recall:    0.9847\n",
      "   Accuracy:  0.9888\n",
      "\n",
      "============================================================\n",
      "\ud83d\udcc8 BORDERLINE TEST (V2 - Harder Evaluation)\n",
      "============================================================\n",
      "\u23f3 Encoding 2500 pairs for Borderline Set...\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Batches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 157/157 [00:04<00:00, 33.89it/s]\n",
      "Batches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 157/157 [00:04<00:00, 32.57it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\ud83d\udcca Borderline Set Results:\n",
      "   Spearman:  -0.1068\n",
      "   Pearson:   -0.1643\n",
      "   ROC-AUC:   0.4321\n",
      "   PR-AUC:    0.2627\n",
      "   Best Threshold: 0.027\n",
      "   F1 @ best: 0.4507\n",
      "   Precision: 0.2909\n",
      "   Recall:    1.0000\n",
      "   Accuracy:  0.2912\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.metrics import (\n",
    "    roc_curve, precision_recall_curve, confusion_matrix,\n",
    "    roc_auc_score, average_precision_score,\n",
    "    precision_score, recall_score, f1_score, accuracy_score\n",
    ")\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\", category=FutureWarning)\n",
    "\n",
    "def comprehensive_eval(examples, model, name=\"\", use_cv_threshold=False):\n",
    "    \"\"\"Run comprehensive evaluation on a set of pairs (V2: with CV threshold option).\"\"\"\n",
    "    texts1 = [ex.texts[0] for ex in examples]\n",
    "    texts2 = [ex.texts[1] for ex in examples]\n",
    "    labels = np.array([ex.label for ex in examples])\n",
    "    \n",
    "    # Encode\n",
    "    log(f\"\u23f3 Encoding {len(examples)} pairs for {name}...\")\n",
    "    emb1 = model.encode(texts1, batch_size=CONFIG['batch_size'], \n",
    "                       show_progress_bar=True, convert_to_numpy=True)\n",
    "    emb2 = model.encode(texts2, batch_size=CONFIG['batch_size'], \n",
    "                       show_progress_bar=True, convert_to_numpy=True)\n",
    "    \n",
    "    # Cosine similarity\n",
    "    scores = np.sum(emb1 * emb2, axis=1) / (\n",
    "        np.linalg.norm(emb1, axis=1) * np.linalg.norm(emb2, axis=1) + 1e-8\n",
    "    )\n",
    "    \n",
    "    # Metrics\n",
    "    spearman, _ = spearmanr(labels, scores)\n",
    "    pearson, _ = pearsonr(labels, scores)\n",
    "    roc_auc = roc_auc_score(labels, scores)\n",
    "    pr_auc = average_precision_score(labels, scores)\n",
    "    \n",
    "    # Find best threshold\n",
    "    fpr, tpr, roc_thresholds = roc_curve(labels, scores)\n",
    "    precision, recall, pr_thresholds = precision_recall_curve(labels, scores)\n",
    "    f1_scores = 2 * (precision * recall) / (precision + recall + 1e-10)\n",
    "    best_idx = np.argmax(f1_scores)\n",
    "    best_threshold = pr_thresholds[best_idx-1] if 0 < best_idx < len(pr_thresholds)+1 else 0.5\n",
    "    \n",
    "    # V2: Use CV threshold if requested\n",
    "    if use_cv_threshold and 'cv_threshold' in globals():\n",
    "        best_threshold = cv_threshold\n",
    "        log(f\"   Using CV threshold: {best_threshold:.4f}\")\n",
    "    \n",
    "    # Metrics at best threshold\n",
    "    preds = (scores >= best_threshold).astype(int)\n",
    "    acc = accuracy_score(labels, preds)\n",
    "    prec = precision_score(labels, preds)\n",
    "    rec = recall_score(labels, preds)\n",
    "    f1 = f1_score(labels, preds)\n",
    "    cm = confusion_matrix(labels, preds)\n",
    "    \n",
    "    log(f\"\\n\ud83d\udcca {name} Results:\")\n",
    "    log(f\"   Spearman:  {spearman:.4f}\")\n",
    "    log(f\"   Pearson:   {pearson:.4f}\")\n",
    "    log(f\"   ROC-AUC:   {roc_auc:.4f}\")\n",
    "    log(f\"   PR-AUC:    {pr_auc:.4f}\")\n",
    "    log(f\"   Best Threshold: {best_threshold:.3f}\")\n",
    "    log(f\"   F1 @ best: {f1:.4f}\")\n",
    "    log(f\"   Precision: {prec:.4f}\")\n",
    "    log(f\"   Recall:    {rec:.4f}\")\n",
    "    log(f\"   Accuracy:  {acc:.4f}\")\n",
    "    \n",
    "    return {\n",
    "        'labels': labels, 'scores': scores,\n",
    "        'spearman': spearman, 'pearson': pearson,\n",
    "        'roc_auc': roc_auc, 'pr_auc': pr_auc,\n",
    "        'fpr': fpr, 'tpr': tpr,\n",
    "        'precision': precision, 'recall': recall,\n",
    "        'best_threshold': best_threshold,\n",
    "        'f1': f1, 'prec': prec, 'rec': rec, 'acc': acc,\n",
    "        'cm': cm, 'texts1': texts1, 'texts2': texts2  # V2: Keep texts for error analysis\n",
    "    }\n",
    "\n",
    "# V2: Get cross-validated threshold first\n",
    "log(\"=\"*60)\n",
    "log(\"\ud83d\udcc8 CROSS-VALIDATED THRESHOLD SELECTION (V2)\")\n",
    "log(\"=\"*60)\n",
    "cv_threshold, cv_std = get_cv_threshold(eval_examples, best_model, n_folds=CONFIG['threshold_cv_folds'])\n",
    "\n",
    "# Evaluate on all sets\n",
    "log(\"\\n\" + \"=\"*60)\n",
    "log(\"\ud83d\udcc8 FINAL EVALUATION\")\n",
    "log(\"=\"*60)\n",
    "\n",
    "eval_results = comprehensive_eval(eval_examples, best_model, \"Eval Set\")\n",
    "holdout_results = comprehensive_eval(holdout_examples, best_model, \"Holdout Set\")\n",
    "\n",
    "# V2 NEW: Evaluate on borderline (harder) test set\n",
    "log(\"\\n\" + \"=\"*60)\n",
    "log(\"\ud83d\udcc8 BORDERLINE TEST (V2 - Harder Evaluation)\")\n",
    "log(\"=\"*60)\n",
    "borderline_results = comprehensive_eval(borderline_examples, best_model, \"Borderline Set\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "48806de7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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v/5qU6ZMsX/++cd1wPjMnz/f2rdv7/5m5s2bZ+PGjbMvvvjC+vXr59/n66+/tuuuu85uu+02t8jj66+/7jqSkr8/KBh2795tv/32m/+6Sk2dddZZzPAEkGeeeOIJFz/onPPf//7XxRM6FwUOLlDCVfv17t3bldhVEkEd9hpUETjLROfNdu3a2bPPPusS+zqHKta48847bejQoe68mBYNVtCaANmNH7J7HNn5TL/ooovc90CVE1TiQQM5NDgjNTkVG7zxxhsu/tPz6fUNHDjQvd4vv/wyV14rwkuzOpVUPHTokLse9cwz1vLaa62Eb8BPsWJmkyaZPfSQOifCe7AAACTnIV27du3SMGX3MyfsO3TYq/PgV+6i3xMTE71Zs2Z5jz/+uPf88897O3fu5F0BMunAgQPeggUL3E8f/dvSv7G8vuh5M6N79+5ehw4dUr29S5cuXqdOnYK2xcfHexUrVvTee+89d/3rr7/2WrVq5ZUtW9arUKGCd+mll3pLly71779ixQr3OTZv3rxUn6d169Ze7969g7adccYZ3pVXXum/rs8qPc6rr76a4v59+/b1ihUr5q1evdpdHzdunNt34sSJKfZVG6X3WTdjxgyvZs2a7rXWqFHD+/nnn4NuHzBggNeoUaMU90v+WrN7HFk1efJkLzo62tu4caN/2xtvvOGVKVPGO3ToUMj7vPnmm16VKlW8hIQE/7Y///zTHf+///7rrj/00ENe06ZNg+73xRdfeLGxsd7u3bv9fzNXX3110D56z2rVqhXy7zPUv5/cOgcWNjnafof3et5oS7rod8/z1q1b57344ovu38Mff/yR/ecA8pkUn0/6DNPffzgumTi/p3Zunz59uvtM2LFjh3/b+PHjvZNPPtmLiYnx6tSp4/5NB9K2l19+2X99yZIl3jnnnOMVL17cO+mkk7xvvvnGPeZnn30WdO5o06aNOzcoLujZs6e3Z8+eNM/5Ol4dt+92PWbgJTXJj0/0nH369PFfHzt2rHsMna+Su+qqq1xMs3dv0ufac889586fc+fOTbGvYgLffql59913vbPOOsud30uUKOGPSzL73mT3OLLq9ddf98qXLx8UKzz44IPeCSeckOp9cio2aNGihXffffeliO8UY6aGGCJ35Hb8dfDgQe/DDz908cOYoUO9xHPP1dzso5ezzsqV5wUAIKfOgdQkCDON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kSPeqaee6l100UXeH3/84U2ZMsWrXLmy99BDD/n3+fXXX70TTjjBW7t2rX/b0KFDvTlz5niLFy/2XnvtNXfcr7zyStBjP//8896ff/7p/f33394TTzzhznOBr0N/O2+88YZ7b/Se33333V5sbKx7vsz++9G5LyfPgQU5fsj1GEIxw+G9SRfiBxQSkXp+17m9Q4cOKbZPnz7dfSbs2LHDXdfnvc6f+izX5/67777rPvdHjRrlv0+dOnW8l19+2X/OVyxw4YUXunPLDz/84DVp0iTonL9v3z53LuzYsaP3119/ed9//71Xr149d0w+w4cP90qUKOF99dVX7lzRs2dPr0yZMkH76Dkuv/xyd45KHpMECjw+n3/++ceLiopy51zfufjKK6/0ypcv77399tsuLpk/f753yy23uLgm8Bymz9FzzjnH7avzoF6nzvHjxo3zzjjjjFRjGbW3zvfJqc2qVavmHkvU9voc79Spk/f777+72Omdd97xSpcu7c6d2T2O7Nq5c6dXtWpV7/rrr3fn+bFjx7r36s033/TvM2HCBBc/5HRsoL/BDz74wFuyZInbrvasUKGCe79SU9BjiAIRP4g+c9asOXrZsCFnHhcAgByW0fiBpEYONiaA8InUTg9RB4I+Y5Jfkn9Z1evTdnUeJE+Ifvvtt95JJ53kkg2nnXaaN2PGjBxJasitt97qkgfqFPDRl391oujLcMmSJd2X/i+++CLFfXUffYFWkkVfyNVhovupk37//v0p9j906JBL0OiLeSjPPfec+0IYHx/v/6Kp9jvmmGNcJ5A6ep599ln/7Vk9jpyi5Mkll1zijq1SpUrevffe65IxyTu3AjsL1ImhDoSYmBj3Xr7//vspHleJnLJly7r2VwJo8uTJQber4+Kss85y741e7wUXXOD98ssvhbZDIi87JQpq+wHhUtCTGjJ+/Hh3/tJnjs5nL7zwQppJA3U8n3322e480aBBA5c0Dzznizq3da7QeULnFCUt9uzZ479d58nbb7/d3abPtEGDBrnjDUxqzJo1y52HFFukNRYuVFJD2rVr586BPjr/6bUpptCx61ysfX766aeQHbw6poYNG/pfQ6tWrVzSJ/A86rNx40aXHPn4449DHqNe6+mnnx7Uhkqy1KhRw50rGzVq5I0YMSJFfJXZ48gpSvjoPVbb16xZ08U2gZT0Sv6e5ERs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BAAAxA+B6IMA8j9magARpHjx4u7kGnjRjIHBgwdbw4YNrWTJkm72wB133GF79+5N9XGUdGjTpo2VLl3aJSOaNGliv//+u//2n376yc455xyLi4tzj3f33Xfbvn370jw2zV7Q8dSoUcPNqtB91Pl/4MABl+h44okn3AwOvYbGjRvblClT/PeNj4+3Xr16WfXq1S02Ntbq1KljgwYNCll+6thjj3U/Tz/9dLf9vPPOSzH74a233nLHoecN1KFDB5eE8Pn888/tjDPOcM9Zr149GzhwoB05ciTN11m0aFH3OmvWrGlt27a1a665xr799lv/7Up23HTTTe441X4nnHCCm0USONvjvffec8/tm/UxY8YMd9uaNWusU6dOrlRYhQoV3PFqZgoAANlFDEEMAQAA8UMS+iDog0DkI6kBFAAq+fTqq6/aP//84zrMv//+e3vggQdS3f+6665zCYbffvvN5syZY/369bNixYq525YtW+ZGc3bs2NH+/PNPNwNBSQ4lHTJDHfpKKihJoE79l156yV588UX3mO3atbPLL7/c/v33X7evjv2LL76wjz/+2M32GD16tNWtWzfk486ePdv9VMJEU0InTJiQYh8lGrZt22bTp0/3b1OJKCVS9Nrlxx9/tG7dulnv3r1twYIF9uabb7ryVU8//XSGX6MSDpqJEhMT49+m16y2/eSTT9zjPvbYY/bwww+71yb33XefS1yojXX8urRs2dIOHz7s2kWJJh3bzz//bKVKlXL7KeACACA3EEMEI4YAAID4IRB9EEA+5QGICN27d/eKFCnilSxZ0n+5+uqrQ+77ySefeBUrVvRfHzVqlFe2bFn/9dKlS3vvvvtuyPvedNNN3i233BK07ccff/Sio6O9AwcOhLxP8sdfsmSJ16BBA69p06bueo0aNbynn3466D5nnnmmd8cdd7jf77rrLu/888/3EhMTQz6+Pqo+++wz9/uKFSvc9Xnz5qVonw4dOviv6/cbb7zRf/3NN990x5GQkOCuX3DBBd4zzzwT9BgffPCBV716dS81AwYMcO2gto+NjXXHocvgwYO9tNx5551ex44dUz1W33OfcMIJQW1w6NAhLy4uzps6dWqajw8AQFqIIYghAADILOIH4gcgP2NNDSCCqGTUG2+84b+uclO+WQsq17Ro0SLbvXu3mx1x8OBB279/v5UoUSLF4/Tt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ni+wrfbv35/i9nbt2nn16tUL2ta6dWt3SX7Meu/T8vbbb7v9/vrrrxS36T3SbaEugwYN8u/XokWLFO04e/Zst9/777+f5mvR40RFRXmrVq3ybxswYIC7b3Lr169325977rk0XxMAIBhxAHFATscBvktgDHTFFVd4MTEx3rJly4LO3YoNzz333HRjusaNG3uHDh3y7/fWW2+5/QLjmyFDhrhtH374oX+b7q9YpFSpUt7u3btDPkda8dGdd94ZMu7wmTlzprt93LhxfLQACAvO45zHc/I83qpVK2/r1q1B++ocrHPxtm3b/Nvmz5/vRUdHe926dUvxXb1Lly5B99+8ebOLAS699NKg/oyHH37Y7a8+mcz2mfjO2eor0uOndz4P1Y+g6zqupUuXBr0ubR86dKh/20033eRVr149Rbtce+21XtmyZUP2ZWTVpEmT3PO/+eabQdvPOussr2bNml5CQkKa9//ggw/c/d95552Qt+v13n777Tl2vMg+yk8BOUBTEpVx1og31e9TWYDPPvssRe3F5DMXNAJOdf00lU1Zft9FWWA9xvTp091+GuW2Z88etzhT8vUv0qrnpxkVqsOo+2eUSjRpep6y7YHPpdqDJ554ok2aNCnkYo+BNJpQIwEzasCAAa79NF1T99VsEs320PTAwLbSbZqdENhWantl3X/44Qe336effuraRI+ZXGBbaTZE4KhIPZZGNei4Q42SzKxt27almG0SSKMq9b4kvwSuwaKajhohEliGS6MMNIpCoxBCvRa933otGpGpWEMjRtLjO8ZQI0YBAOkjDiAOyKk4QLNeAynG+eabb1yZT43y9KlevbqbqatRkhrpmFZMpzgtsMSCZl8o/ky+qLfisMA4RDNCNIt47969bkZITiP+AJBfcB7nPJ6d8/hXX31lTz/9tJt5qNmQvjLQmh2hckU67wbOHNDC1OoD0rk3vb4VzfTQjIy77rorqD8j1AyHjPaZ+GhWhfphskqPqwodga9Ls0p9fUHqj1D/zGWXXeZ+DzwmVftQv4tmneQUzV7R6wksQaVKKKrYofhGa2OkZtGiRa5iR4sWLax79+4h9/G1K/IPyk8BOUA1gxs0aODKGKlO4AknnJDiA1O3qQZiIC0gpQ9yresQir6Iiq9TO7NT85WYUKkiTXdUgkUf8iprpPUlUuNbw0GvITklNfTlOZBvzYrk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0rNnTze6XwO+NRo/0J133mnbt293I+m1CLlKTqlju0ePHq6zPjcp0aB1QjRbQyWg9NpV+qh///45+jxqg7vvvtvNQlBZq+S2bNliX375pWvfU089Neii/uWJEye6NhKtfaSZHupb1toZ6o/W4uYqG+ZLauj5tBaHOv21ALraXf3Sf/75p0scqIxTalR6SgmbtC5pJZ/69u3rZviolJbaU+unKBmm99NHrylwMXHN0nn00UfdmiJKbvn+FvU36HP//fe7kl567KVLl7pyX2qzO+64w92u1zdo0CCX8FH/vEpTXXPNNa5CUvv27S3XeBFm+vTpKk6W4tK9e3d3u362bt06xX0aN27sxcTEePXq1fNGjRqVqefctWuXew79BAAgr131+s9enQe/8q6/ZqCXWKSI50VHq4BE6hfdrv2mTMn2cxekcyAxBACgwEpM9LzxlT1vtB29PKiYwPI0biiIMUSBiB/uvjvpvX7kkZx5PCCfOXDggLdgwQL3M5Lo8yPwc6V06dLemWee6Y0fPz5ovz///NNr06aNFxsb61WoUMHr2bOnt2fPnqDH6dChQ4rHnzVrlteoUSP3WaTPpE8//dQ9z7x58/z7LFmyxLvyyiu9cuXKeXFxcd6JJ57o3XPPPV6iziue5z7fevfuneKx9TifffaZ+33FihVBj+v73NyxY4d/f92mbdrXZ8qUKV7Lli3d85YpU8Zr1qyZ99Zbb6XaXgMGDHCvJzXJj8Nn3759Xvny5b3nnnsuxX1efPFF99rj4+NT3Hbo0CF32yuvvOLfNnr0aK9JkybuvapatarXvn17b/78+Snuu3jxYq9bt25ejRo1XPvXqVPH69Klizd37lwvNw0dOtQ75phj3HOqPX/55Zeg2/V++s5fouMKdY5TWwd65513vPr167u/Qb0HEydO9N+2bt0675JLLvGqVKniFStWzKtVq5bXtWtXb9GiRVn6N5vRc2CU/pd7KZOCYffu3a4mmOqmaS0OAADykk7Vjfp8bLNev8FiDx+yIi7OSIemuWrtqLVrs1WKinNg9tB+AIA8k3jEbOefZlOamO0zs7vMLP5/3RN5FDcE4hyYj9qud2+zV181U2mVTNToByKFSiypksuxxx6ba4sSA8ibf7MZPQdGXPkpAAAKG01h7RV9n58AAQAASURBVPj3NIvLaEJDtACbpte+/35uHx4A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RhC7//77TUVB+uXGG2/M0/O47rrrXM8dHR0ttWrVktdee821febMma7toaGhUq5cObnrrrtk165d2Xr8lStXSlhYmHTo0OGcbcuXLzePe/To0WxVtCxbtkzat28vJUqUMBNO6rn+5z//kX/++Ud85fTp09KvXz/znAULFpTOnTvL/v37szxGt+v7W758eXOe+p5u377dY58//vhDbr31VilVqpQULlxY7rzzznMe96effpIbbrhBihYtap6/V69eEhcX55PXCQBwBr2+dOrUKUfXVCcmU+z97BgkNjZWrrjiCvnwww9d20eOHOnarrFGxYoVzbXy8OHD2TqP999/3xyn1/n0NP7R6292Ez3//e9/TUxVpEgREy/Uq1dPRo8ene1zyQ197K5du5o4Qs+1R48e540TvBV/LFmyRJo1ayaFChWSsmXLypNPPinJyck+eZ0AEFBIagAAAgBJjSCnld179+71WPQHdl7r2bOnee4tW7aYH7f64979PPRHr27X5IH+aN+2bZvccccd2Xrst99+Wx555BH59ttvZc+ePbk+x2nTpknr1q3ND2c9Bz3XqVOnyrFjx+T//u//xFcGDBggn3/+ualE+eabb8xruO222zLd37IsU9n0559/yv/+9z/5+eefpXLlyubc4+PjzT76t02bNqZSZOnSpfLDDz9IYmKi3HzzzZKammr20efRYy655BL58ccfZeHChbJ582ZTmQUAQLDQxIDGIHo9bdy4sWlYsWLFCtf22rVrm+3a2GLGjBnmetmnT59sxyiDBw82MY82YsitoUOHmvPS8/vyyy9l06ZNJjb55Zdf5N133xVf0YSGxgaLFi2S+fPnm1hLExCZ8Vb8oa9LG5loHKvvy7x58+Szzz6Tp556ymevFQACBkkNAEAgsHBex44ds7So9G96p06dsrZs2WL+2lJTU634hCS/LPrc2dW9e3erY8eOmW6/++67rTvvvNPjvsTERKtEiRLWrFmzzO0vv/zSuvrqq60iRYpYxYsXtzp06GD9/vvvrv137Nhhyu7nn3/O9HlatGhhPfbYYx73Va9e3erSpYtZnzFjhnl8d5MmTcr0PXF34sQJq2DBgtavv/5q3XXXXdbzzz/vsX3ZsmXmcY4cOXLOsZUrV7ZeeeUVs757924rMjLSevzxxzN8noyO94ajR49aERER1ocffui6b+vW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",
      "text/plain": [
       "<Figure size 1600x1400 with 9 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\ud83d\udcca Plots saved to models\\real_servicenow_finetuned_mpnet_lora\\real_servicenow_v2_20251224_0449\\evaluation_plots_v2.png\n"
     ]
    }
   ],
   "source": [
    "# Visualization (V2: Added borderline results)\n",
    "fig, axes = plt.subplots(3, 3, figsize=(16, 14))\n",
    "\n",
    "# ROC Curves\n",
    "axes[0,0].plot(eval_results['fpr'], eval_results['tpr'], \n",
    "               label=f\"Eval ROC-AUC = {eval_results['roc_auc']:.3f}\")\n",
    "axes[0,0].plot([0,1], [0,1], 'k--', alpha=0.5)\n",
    "axes[0,0].set_title('ROC Curve (Eval)')\n",
    "axes[0,0].set_xlabel('False Positive Rate')\n",
    "axes[0,0].set_ylabel('True Positive Rate')\n",
    "axes[0,0].legend()\n",
    "\n",
    "axes[0,1].plot(holdout_results['fpr'], holdout_results['tpr'], \n",
    "               label=f\"Holdout ROC-AUC = {holdout_results['roc_auc']:.3f}\", color='orange')\n",
    "axes[0,1].plot([0,1], [0,1], 'k--', alpha=0.5)\n",
    "axes[0,1].set_title('ROC Curve (Holdout)')\n",
    "axes[0,1].set_xlabel('False Positive Rate')\n",
    "axes[0,1].set_ylabel('True Positive Rate')\n",
    "axes[0,1].legend()\n",
    "\n",
    "# V2 NEW: Borderline ROC\n",
    "axes[0,2].plot(borderline_results['fpr'], borderline_results['tpr'], \n",
    "               label=f\"Borderline ROC-AUC = {borderline_results['roc_auc']:.3f}\", color='red')\n",
    "axes[0,2].plot([0,1], [0,1], 'k--', alpha=0.5)\n",
    "axes[0,2].set_title('ROC Curve (Borderline - V2)')\n",
    "axes[0,2].set_xlabel('False Positive Rate')\n",
    "axes[0,2].set_ylabel('True Positive Rate')\n",
    "axes[0,2].legend()\n",
    "\n",
    "# PR Curves\n",
    "axes[1,0].plot(eval_results['recall'], eval_results['precision'], \n",
    "               label=f\"Eval PR-AUC = {eval_results['pr_auc']:.3f}\")\n",
    "axes[1,0].scatter([eval_results['rec']], [eval_results['prec']], \n",
    "                  color='red', s=100, zorder=5,\n",
    "                  label=f\"Best F1={eval_results['f1']:.3f}\")\n",
    "axes[1,0].set_title('Precision-Recall (Eval)')\n",
    "axes[1,0].set_xlabel('Recall')\n",
    "axes[1,0].set_ylabel('Precision')\n",
    "axes[1,0].legend()\n",
    "\n",
    "axes[1,1].plot(holdout_results['recall'], holdout_results['precision'], \n",
    "               label=f\"Holdout PR-AUC = {holdout_results['pr_auc']:.3f}\", color='orange')\n",
    "axes[1,1].scatter([holdout_results['rec']], [holdout_results['prec']], \n",
    "                  color='red', s=100, zorder=5,\n",
    "                  label=f\"Best F1={holdout_results['f1']:.3f}\")\n",
    "axes[1,1].set_title('Precision-Recall (Holdout)')\n",
    "axes[1,1].set_xlabel('Recall')\n",
    "axes[1,1].set_ylabel('Precision')\n",
    "axes[1,1].legend()\n",
    "\n",
    "# V2 NEW: Borderline PR\n",
    "axes[1,2].plot(borderline_results['recall'], borderline_results['precision'], \n",
    "               label=f\"Borderline PR-AUC = {borderline_results['pr_auc']:.3f}\", color='red')\n",
    "axes[1,2].scatter([borderline_results['rec']], [borderline_results['prec']], \n",
    "                  color='green', s=100, zorder=5,\n",
    "                  label=f\"Best F1={borderline_results['f1']:.3f}\")\n",
    "axes[1,2].set_title('Precision-Recall (Borderline - V2)')\n",
    "axes[1,2].set_xlabel('Recall')\n",
    "axes[1,2].set_ylabel('Precision')\n",
    "axes[1,2].legend()\n",
    "\n",
    "# Score Distributions\n",
    "for idx, (results, name, color) in enumerate([\n",
    "    (eval_results, 'Eval', 'blue'), \n",
    "    (holdout_results, 'Holdout', 'orange'),\n",
    "    (borderline_results, 'Borderline', 'red')\n",
    "]):\n",
    "    ax = axes[2, idx]\n",
    "    neg_scores = results['scores'][results['labels'] == 0]\n",
    "    pos_scores = results['scores'][results['labels'] == 1]\n",
    "    \n",
    "    ax.hist(neg_scores, bins=30, alpha=0.6, label='Negative (0)', color='blue')\n",
    "    ax.hist(pos_scores, bins=30, alpha=0.6, label='Positive (1)', color='orange')\n",
    "    ax.axvline(results['best_threshold'], color='red', linestyle='--', \n",
    "               label=f\"Threshold={results['best_threshold']:.3f}\")\n",
    "    ax.axvline(cv_threshold, color='green', linestyle=':', \n",
    "               label=f\"CV Threshold={cv_threshold:.3f}\")\n",
    "    ax.set_title(f'Score Distribution ({name})')\n",
    "    ax.set_xlabel('Cosine Similarity')\n",
    "    ax.set_ylabel('Count')\n",
    "    ax.legend(fontsize=8)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig(save_path / 'evaluation_plots_v2.png', dpi=150)\n",
    "plt.show()\n",
    "\n",
    "log(f\"\\n\ud83d\udcca Plots saved to {save_path / 'evaluation_plots_v2.png'}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "92aa08e9",
   "metadata": {},
   "source": [
    "# 7.1 Error Analysis (V2 NEW)\n",
    "\n",
    "Systematically analyze failure patterns to identify:\n",
    "1. **Worst False Positives**: High-scoring pairs that should be dissimilar\n",
    "2. **Worst False Negatives**: Low-scoring pairs that should be similar\n",
    "3. **Category/text length patterns** in errors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cda41096",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "============================================================\n",
      "\ud83d\udd0d ERROR ANALYSIS: Eval Set\n",
      "============================================================\n",
      "Total pairs: 7,480\n",
      "False Positives: 48 (0.64%)\n",
      "False Negatives: 22 (0.29%)\n",
      "\n",
      "\ud83d\udcdb WORST FALSE POSITIVES (Top 5):\n",
      "   These pairs scored HIGH but should be DISSIMILAR\n",
      "\n",
      "   [1] Score: 0.7953\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction. Please find the details below and att...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction Interface PANA.CART-PRD.MARKETING.Q Su...\n",
      "\n",
      "   [2] Score: 0.7510\n",
      "       Text 1: In relation to our External Auditor (SGV) request System and Organization Controls Report (SOC) for ...\n",
      "       Text 2: Please check this FPL : 6X4A00601822 and reprocess to IDOC because it's not auto created inbound del...\n",
      "\n",
      "   [3] Score: 0.7047\n",
      "       Text 1: REFER TO ATTACHMENT BELOW, PART ALREADY DELIVERED AND WE ALREADY REPAIR THE CUSTOMER SET. JOB CAN'T ...\n",
      "       Text 2: Work Order was created without an asset or model number. With this, work order cannot be updated bec...\n",
      "\n",
      "   [4] Score: 0.6865\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction. Please find the details below and att...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction Interface internal-stocks Subsidiary P...\n",
      "\n",
      "   [5] Score: 0.5935\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction Interface internal-stocks Subsidiary P...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction. Please find the details below and att...\n",
      "\n",
      "\ud83d\udcdb WORST FALSE NEGATIVES (Top 5):\n",
      "   These pairs scored LOW but should be SIMILAR\n",
      "\n",
      "   [1] Score: 0.0178\n",
      "       Text 1: invoiced in SAP mismatched in SF., ref PPH-SO-2409004128 with WO PPH-WO-2409003229, still in backord...\n",
      "       Text 2: SO numbers: PPH-SO-2409000730 PPH-SO-2409001050 PPH-SO-2409001966 PPH-SO-2408007572 PPH-SO-240900155...\n",
      "\n",
      "   [2] Score: 0.0499\n",
      "       Text 1: REMOVE PRICING FOR ALL ITEMS IN \"WORK ORDER LINE ITEMS\" (Context: [crm (d365, salesforce, genesis, p...\n",
      "       Text 2: H Team, Issue: The All Purchase Order Received checkbox (hm_All_Purchase_Order_Received__c) is not e...\n",
      "\n",
      "   [3] Score: 0.0661\n",
      "       Text 1: Please check why invoice no. 1501107255 (INV33709) was triggered to post again at 5/5/25, 9.50pm alt...\n",
      "       Text 2: Please check why invoice no. 1501107255 (INV33709) was triggered to post again at 5/5/25, 9.50pm alt...\n",
      "\n",
      "   [4] Score: 0.0713\n",
      "       Text 1: Kindly cancel the following SO, partner portal user will repeat the process to order again since iss...\n",
      "       Text 2: SO numbers: PPH-SO-2409000730 PPH-SO-2409001050 PPH-SO-2409001966 PPH-SO-2408007572 PPH-SO-240900155...\n",
      "\n",
      "   [5] Score: 0.1300\n",
      "       Text 1: User : Geri SO : 110048734 line item 10 Material UEX13EBPN Customer request date : 21.06.2024 AB con...\n",
      "       Text 2: User: Chris Chee eTR-S1-24000197 The calculation of daily allowance is incorrect. Pls kindly advise....\n",
      "\n",
      "\ud83d\udccf TEXT LENGTH ANALYSIS:\n",
      "   Overall avg length: 546 chars\n",
      "   FP pairs avg length: 1119 chars\n",
      "   FN pairs avg length: 908 chars\n",
      "\n",
      "\ud83d\udcca SCORE DISTRIBUTION IN ERRORS:\n",
      "   FP scores: min=0.3232, max=0.7953, mean=0.4723\n",
      "   FN scores: min=0.0178, max=0.3220, mean=0.2144\n",
      "\n",
      "============================================================\n",
      "\ud83d\udd0d ERROR ANALYSIS: Holdout Set\n",
      "============================================================\n",
      "Total pairs: 5,000\n",
      "False Positives: 33 (0.66%)\n",
      "False Negatives: 23 (0.46%)\n",
      "\n",
      "\ud83d\udcdb WORST FALSE POSITIVES (Top 5):\n",
      "   These pairs scored HIGH but should be DISSIMILAR\n",
      "\n",
      "   [1] Score: 0.7880\n",
      "       Text 1: Request to change WO in-warranty and Claimable Flag to True since creation date and expiry date on s...\n",
      "       Text 2: murata.kumiko@kk.jp.panasonic.com created new FAQs for PGI as below. https://p-cube.lightning.force....\n",
      "\n",
      "   [2] Score: 0.7529\n",
      "       Text 1: Pls check PSV-SO-2503011309 CS LABOUR & CS TRANSPORT V-invoice number has not been respond from SAP ...\n",
      "       Text 2: Please retriger SAP sync for Work order below: 1) PM-WO-2406001346 - PM-SO-2406001541 2) PM-WO-24060...\n",
      "\n",
      "   [3] Score: 0.6450\n",
      "       Text 1: Asset Name : 07400166 in PGI-WO-2409007400 is already register 27/08/2024 but Warranty expiry date i...\n",
      "       Text 2: PM-SO-2405005692 SALES ORDER NOT TRIGGERED TO SAP - PART STILL UNDER PART REQUESTED. - SEEK ASSISTAN...\n",
      "\n",
      "   [4] Score: 0.5861\n",
      "       Text 1: Pls check PSV-WO-2410004921 no DO & PSV-WO-2410006135 (K24TSS;00013753) Invoice number has not been ...\n",
      "       Text 2: Kindly check the following SF claim ID. as feedback from finance, it didnt reflect in SAP. Claim-000...\n",
      "\n",
      "   [5] Score: 0.4951\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction Interface change-over Subsidiary PAU A...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction Interface GSSI Subsidiary No Subsidiar...\n",
      "\n",
      "\ud83d\udcdb WORST FALSE NEGATIVES (Top 5):\n",
      "   These pairs scored LOW but should be SIMILAR\n",
      "\n",
      "   [1] Score: 0.0258\n",
      "       Text 1: Please resend these EWS orders to SAP (Context: [crm (d365, salesforce, genesis, pcube, hussmann ser...\n",
      "       Text 2: Please resend these EWS orders to SAP (Context: [sap | fico - finance & controlling] [application/so...\n",
      "\n",
      "   [2] Score: 0.0822\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction. Please find the details below and att...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction Interface avnet Subsidiary PIDSMY API ...\n",
      "\n",
      "   [3] Score: 0.1004\n",
      "       Text 1: When using t-code MIRO, invoice 00335782, PO 4600291359, part 7030093, an error occurs stating that ...\n",
      "       Text 2: Request to check detail of GL 720102-088 (Context: [sap | fico - finance & controlling] [application...\n",
      "\n",
      "   [4] Score: 0.1318\n",
      "       Text 1: ICWorkOrderTrigger: Appear if save after key in asset number. WO: PM-WO-2406001481 Please refer the ...\n",
      "       Text 2: SAP part had been delivered but data not sync to SF affected WO as below: 1) PM-WO-2405004281 - PM-S...\n",
      "\n",
      "   [5] Score: 0.1633\n",
      "       Text 1: Invoice is not issued in PSV-WO-2401001775 - PSV-SO-2401003806 and PSV-WO-2407012487 - PSV-SO-240701...\n",
      "       Text 2: The order PSV-WO-2412006135 / PSV-SO-2412005529 and PSV-WO-2504003336 / PSV-SO-2504000898 have been ...\n",
      "\n",
      "\ud83d\udccf TEXT LENGTH ANALYSIS:\n",
      "   Overall avg length: 556 chars\n",
      "   FP pairs avg length: 3800 chars\n",
      "   FN pairs avg length: 1039 chars\n",
      "\n",
      "\ud83d\udcca SCORE DISTRIBUTION IN ERRORS:\n",
      "   FP scores: min=0.2807, max=0.7880, mean=0.4187\n",
      "   FN scores: min=0.0258, max=0.2686, mean=0.1996\n",
      "\n",
      "============================================================\n",
      "\ud83d\udd0d ERROR ANALYSIS: Borderline Set\n",
      "============================================================\n",
      "Total pairs: 2,500\n",
      "False Positives: 1,772 (70.88%)\n",
      "False Negatives: 0 (0.00%)\n",
      "\n",
      "\ud83d\udcdb WORST FALSE POSITIVES (Top 5):\n",
      "   These pairs scored HIGH but should be DISSIMILAR\n",
      "\n",
      "   [1] Score: 0.9962\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction Interface Subsidiary PIDSAP API Name e...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction Interface AGENT_CPO Subsidiary PIDSKR ...\n",
      "\n",
      "   [2] Score: 0.9961\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction Interface Subsidiary PIDSAP API Name e...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction Interface AGENT_CPO Subsidiary PIDSKR ...\n",
      "\n",
      "   [3] Score: 0.9961\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction Interface Subsidiary PIDSAP API Name e...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction Interface AGENT_CPO Subsidiary PIDSKR ...\n",
      "\n",
      "   [4] Score: 0.9960\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction Interface AGENT_CPO Subsidiary PIDSKR ...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction Interface Subsidiary PIDSAP API Name e...\n",
      "\n",
      "   [5] Score: 0.9959\n",
      "       Text 1: Dear Team Error occurred while processing the EDI transaction Interface AGENT_CPO Subsidiary PIDSKR ...\n",
      "       Text 2: Dear Team Error occurred while processing the EDI transaction Interface Subsidiary PIDSAP API Name e...\n",
      "\n",
      "\ud83d\udccf TEXT LENGTH ANALYSIS:\n",
      "   Overall avg length: 473 chars\n",
      "   FP pairs avg length: 921 chars\n",
      "   FN pairs avg length: 0 chars\n",
      "\n",
      "\ud83d\udcca SCORE DISTRIBUTION IN ERRORS:\n",
      "   FP scores: min=0.0266, max=0.9962, mean=0.7935\n",
      "\n",
      "============================================================\n",
      "\ud83d\udcca ERROR SUMMARY COMPARISON\n",
      "============================================================\n",
      "Set             FP Count     FN Count     FP Rate      FN Rate     \n",
      "------------------------------------------------------------\n",
      "Eval            48           22           0.64        % 0.29        %\n",
      "Holdout         33           23           0.66        % 0.46        %\n",
      "Borderline      1772         0            70.88       % 0.00        %\n"
     ]
    }
   ],
   "source": [
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "# V2 NEW: ERROR ANALYSIS\n",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "\n",
    "def analyze_errors(results, name=\"\", top_k=10):\n",
    "    \"\"\"\n",
    "    Analyze systematic failure patterns in model predictions.\n",
    "    \n",
    "    Returns insights about:\n",
    "    - Worst false positives (high score, label=0)\n",
    "    - Worst false negatives (low score, label=1)\n",
    "    - Text length patterns\n",
    "    \"\"\"\n",
    "    labels = results['labels']\n",
    "    scores = results['scores']\n",
    "    texts1 = results['texts1']\n",
    "    texts2 = results['texts2']\n",
    "    threshold = results['best_threshold']\n",
    "    \n",
    "    # Identify errors\n",
    "    preds = (scores >= threshold).astype(int)\n",
    "    \n",
    "    # False Positives: predicted 1, actual 0\n",
    "    fp_mask = (preds == 1) & (labels == 0)\n",
    "    fp_indices = np.where(fp_mask)[0]\n",
    "    fp_scores = scores[fp_mask]\n",
    "    \n",
    "    # False Negatives: predicted 0, actual 1\n",
    "    fn_mask = (preds == 0) & (labels == 1)\n",
    "    fn_indices = np.where(fn_mask)[0]\n",
    "    fn_scores = scores[fn_mask]\n",
    "    \n",
    "    log(f\"\\n{'='*60}\")\n",
    "    log(f\"\ud83d\udd0d ERROR ANALYSIS: {name}\")\n",
    "    log(f\"{'='*60}\")\n",
    "    log(f\"Total pairs: {len(labels):,}\")\n",
    "    log(f\"False Positives: {len(fp_indices):,} ({len(fp_indices)/len(labels)*100:.2f}%)\")\n",
    "    log(f\"False Negatives: {len(fn_indices):,} ({len(fn_indices)/len(labels)*100:.2f}%)\")\n",
    "    \n",
    "    # Worst False Positives (highest scoring negatives)\n",
    "    if len(fp_indices) > 0:\n",
    "        log(f\"\\n\ud83d\udcdb WORST FALSE POSITIVES (Top {min(top_k, len(fp_indices))}):\")\n",
    "        log(f\"   These pairs scored HIGH but should be DISSIMILAR\")\n",
    "        worst_fp_order = np.argsort(fp_scores)[::-1][:top_k]\n",
    "        \n",
    "        for rank, idx in enumerate(worst_fp_order):\n",
    "            orig_idx = fp_indices[idx]\n",
    "            score = scores[orig_idx]\n",
    "            t1, t2 = texts1[orig_idx], texts2[orig_idx]\n",
    "            log(f\"\\n   [{rank+1}] Score: {score:.4f}\")\n",
    "            log(f\"       Text 1: {t1[:100]}...\")\n",
    "            log(f\"       Text 2: {t2[:100]}...\")\n",
    "    \n",
    "    # Worst False Negatives (lowest scoring positives)\n",
    "    if len(fn_indices) > 0:\n",
    "        log(f\"\\n\ud83d\udcdb WORST FALSE NEGATIVES (Top {min(top_k, len(fn_indices))}):\")\n",
    "        log(f\"   These pairs scored LOW but should be SIMILAR\")\n",
    "        worst_fn_order = np.argsort(fn_scores)[:top_k]\n",
    "        \n",
    "        for rank, idx in enumerate(worst_fn_order):\n",
    "            orig_idx = fn_indices[idx]\n",
    "            score = scores[orig_idx]\n",
    "            t1, t2 = texts1[orig_idx], texts2[orig_idx]\n",
    "            log(f\"\\n   [{rank+1}] Score: {score:.4f}\")\n",
    "            log(f\"       Text 1: {t1[:100]}...\")\n",
    "            log(f\"       Text 2: {t2[:100]}...\")\n",
    "    \n",
    "    # Text length analysis\n",
    "    log(f\"\\n\ud83d\udccf TEXT LENGTH ANALYSIS:\")\n",
    "    all_lengths = [len(t) for t in texts1 + texts2]\n",
    "    fp_lengths = [len(texts1[i]) + len(texts2[i]) for i in fp_indices] if len(fp_indices) > 0 else [0]\n",
    "    fn_lengths = [len(texts1[i]) + len(texts2[i]) for i in fn_indices] if len(fn_indices) > 0 else [0]\n",
    "    \n",
    "    log(f\"   Overall avg length: {np.mean(all_lengths):.0f} chars\")\n",
    "    log(f\"   FP pairs avg length: {np.mean(fp_lengths):.0f} chars\")\n",
    "    log(f\"   FN pairs avg length: {np.mean(fn_lengths):.0f} chars\")\n",
    "    \n",
    "    # Score distribution in errors\n",
    "    log(f\"\\n\ud83d\udcca SCORE DISTRIBUTION IN ERRORS:\")\n",
    "    if len(fp_scores) > 0:\n",
    "        log(f\"   FP scores: min={fp_scores.min():.4f}, max={fp_scores.max():.4f}, mean={fp_scores.mean():.4f}\")\n",
    "    if len(fn_scores) > 0:\n",
    "        log(f\"   FN scores: min={fn_scores.min():.4f}, max={fn_scores.max():.4f}, mean={fn_scores.mean():.4f}\")\n",
    "    \n",
    "    return {\n",
    "        'fp_count': len(fp_indices),\n",
    "        'fn_count': len(fn_indices),\n",
    "        'fp_scores': fp_scores,\n",
    "        'fn_scores': fn_scores,\n",
    "        'fp_avg_length': np.mean(fp_lengths),\n",
    "        'fn_avg_length': np.mean(fn_lengths)\n",
    "    }\n",
    "\n",
    "# Run error analysis on all sets\n",
    "eval_errors = analyze_errors(eval_results, \"Eval Set\", top_k=5)\n",
    "holdout_errors = analyze_errors(holdout_results, \"Holdout Set\", top_k=5)\n",
    "borderline_errors = analyze_errors(borderline_results, \"Borderline Set\", top_k=5)\n",
    "\n",
    "# Summary comparison\n",
    "log(f\"\\n{'='*60}\")\n",
    "log(f\"\ud83d\udcca ERROR SUMMARY COMPARISON\")\n",
    "log(f\"{'='*60}\")\n",
    "log(f\"{'Set':<15} {'FP Count':<12} {'FN Count':<12} {'FP Rate':<12} {'FN Rate':<12}\")\n",
    "log(f\"{'-'*60}\")\n",
    "for name, errors, results in [\n",
    "    (\"Eval\", eval_errors, eval_results),\n",
    "    (\"Holdout\", holdout_errors, holdout_results),\n",
    "    (\"Borderline\", borderline_errors, borderline_results)\n",
    "]:\n",
    "    total = len(results['labels'])\n",
    "    fp_rate = errors['fp_count'] / total * 100\n",
    "    fn_rate = errors['fn_count'] / total * 100\n",
    "    log(f\"{name:<15} {errors['fp_count']:<12} {errors['fn_count']:<12} {fp_rate:<12.2f}% {fn_rate:<12.2f}%\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b07f0d5d",
   "metadata": {},
   "source": [
    "# 8. Adversarial Diagnostic (V2: Enhanced)\n",
    "\n",
    "**Critical validation**: Test if the model learned semantic content or is exploiting category shortcuts.\n",
    "\n",
    "- **Hard Positives**: Cross-category pairs with HIGH content similarity\n",
    "- **Hard Negatives**: Same-category pairs with LOW content similarity\n",
    "\n",
    "**V2 Enhancements:**\n",
    "- Stricter TF-IDF thresholds for adversarial pairs\n",
    "- Compare with borderline test performance\n",
    "\n",
    "**Pass Criteria**: ROC-AUC \u2265 0.70 AND F1 \u2265 0.65"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "94893294",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "============================================================\n",
      "\ud83d\udd2c ADVERSARIAL DIAGNOSTIC: Testing Category Leakage\n",
      "============================================================\n",
      "\u23f3 Building TF-IDF for adversarial pair mining...\n",
      "\u23f3 Building TF-IDF matrix...\n",
      "\u2705 TF-IDF matrix: (1049, 5031) (vocab size: 5031)\n",
      "\u23f3 Mining adversarial pairs...\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Adversarial pairs: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 600/600 [00:16<00:00, 37.20it/s] \n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u2705 Generated 300 hard positives, 300 hard negatives\n",
      "\u23f3 Encoding 600 pairs for Adversarial...\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Batches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 38/38 [00:01<00:00, 30.44it/s]\n",
      "Batches: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 38/38 [00:01<00:00, 32.11it/s]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "\ud83d\udcca Adversarial Results:\n",
      "   Spearman:  0.8522\n",
      "   Pearson:   0.9315\n",
      "   ROC-AUC:   0.9920\n",
      "   PR-AUC:    0.9935\n",
      "   Best Threshold: 0.442\n",
      "   F1 @ best: 0.9649\n",
      "   Precision: 0.9666\n",
      "   Recall:    0.9633\n",
      "   Accuracy:  0.9650\n",
      "\n",
      "============================================================\n",
      "\ud83c\udfaf ADVERSARIAL DIAGNOSTIC RESULTS\n",
      "============================================================\n",
      "Standard Eval ROC-AUC:     0.9993\n",
      "Adversarial ROC-AUC:       0.9920\n",
      "Adversarial F1 @ best:     0.9649\n",
      "\n",
      "\u2705 VERDICT: Model is ROBUST to category shortcuts!\n",
      "   \u2192 Performance holds when categories don't predict similarity\n",
      "   \u2192 Model learned semantic content understanding\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "39137"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "log(\"=\"*60)\n",
    "log(\"\ud83d\udd2c ADVERSARIAL DIAGNOSTIC: Testing Category Leakage\")\n",
    "log(\"=\"*60)\n",
    "\n",
    "# Use holdout data for adversarial test (completely unseen)\n",
    "diag_df = holdout_df.reset_index(drop=True)\n",
    "\n",
    "# Build content-only text (remove category context to test pure semantic understanding)\n",
    "diag_df['content_only'] = diag_df['Description'].str.strip()\n",
    "\n",
    "# Build TF-IDF on content-only text\n",
    "log(\"\u23f3 Building TF-IDF for adversarial pair mining...\")\n",
    "diag_tfidf = TFIDFSimilarityCalculator(diag_df['content_only'].tolist(), max_features=10000)\n",
    "\n",
    "# Generate adversarial pairs\n",
    "hard_positives = []  # Cross-category, high TF-IDF\n",
    "hard_negatives = []  # Same-category, low TF-IDF\n",
    "\n",
    "target_each = 300\n",
    "attempts, max_attempts = 0, 100000\n",
    "\n",
    "log(\"\u23f3 Mining adversarial pairs...\")\n",
    "pbar = tqdm(total=target_each * 2, desc=\"Adversarial pairs\")\n",
    "\n",
    "while (len(hard_positives) < target_each or len(hard_negatives) < target_each) and attempts < max_attempts:\n",
    "    attempts += 1\n",
    "    i1, i2 = random.sample(range(len(diag_df)), 2)\n",
    "    \n",
    "    cat1 = diag_df.at[i1, 'category_id']\n",
    "    cat2 = diag_df.at[i2, 'category_id']\n",
    "    tfidf_sim = diag_tfidf.similarity(i1, i2)\n",
    "    \n",
    "    # Hard Positive: DIFFERENT category but HIGH content similarity\n",
    "    if len(hard_positives) < target_each and cat1 != cat2 and tfidf_sim > 0.4:\n",
    "        hard_positives.append(InputExample(\n",
    "            texts=[diag_df.at[i1, 'content_only'], diag_df.at[i2, 'content_only']],\n",
    "            label=1.0\n",
    "        ))\n",
    "        pbar.update(1)\n",
    "    \n",
    "    # Hard Negative: SAME category but LOW content similarity\n",
    "    if len(hard_negatives) < target_each and cat1 == cat2 and tfidf_sim < 0.15:\n",
    "        hard_negatives.append(InputExample(\n",
    "            texts=[diag_df.at[i1, 'content_only'], diag_df.at[i2, 'content_only']],\n",
    "            label=0.0\n",
    "        ))\n",
    "        pbar.update(1)\n",
    "\n",
    "pbar.close()\n",
    "\n",
    "log(f\"\u2705 Generated {len(hard_positives)} hard positives, {len(hard_negatives)} hard negatives\")\n",
    "\n",
    "# Evaluate on adversarial pairs\n",
    "adversarial_examples = hard_positives + hard_negatives\n",
    "if len(adversarial_examples) >= 100:\n",
    "    adv_results = comprehensive_eval(adversarial_examples, best_model, \"Adversarial\")\n",
    "    \n",
    "    log(\"\\n\" + \"=\"*60)\n",
    "    log(\"\ud83c\udfaf ADVERSARIAL DIAGNOSTIC RESULTS\")\n",
    "    log(\"=\"*60)\n",
    "    log(f\"Standard Eval ROC-AUC:     {eval_results['roc_auc']:.4f}\")\n",
    "    log(f\"Adversarial ROC-AUC:       {adv_results['roc_auc']:.4f}\")\n",
    "    log(f\"Adversarial F1 @ best:     {adv_results['f1']:.4f}\")\n",
    "    \n",
    "    # Verdict\n",
    "    if adv_results['roc_auc'] >= 0.70 and adv_results['f1'] >= 0.65:\n",
    "        log(\"\\n\u2705 VERDICT: Model is ROBUST to category shortcuts!\")\n",
    "        log(\"   \u2192 Performance holds when categories don't predict similarity\")\n",
    "        log(\"   \u2192 Model learned semantic content understanding\")\n",
    "        DIAGNOSTIC_PASSED = True\n",
    "    else:\n",
    "        log(\"\\n\u26a0\ufe0f VERDICT: Model may be exploiting category shortcuts\")\n",
    "        log(\"   \u2192 Consider increasing hard negatives ratio\")\n",
    "        log(\"   \u2192 Or remove category context from training text\")\n",
    "        DIAGNOSTIC_PASSED = False\n",
    "else:\n",
    "    log(\"\u26a0\ufe0f Could not generate enough adversarial pairs\")\n",
    "    DIAGNOSTIC_PASSED = None\n",
    "\n",
    "# Cleanup\n",
    "del diag_tfidf\n",
    "gc.collect()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3fd02e18",
   "metadata": {},
   "source": [
    "# 9. Save Training Metadata"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4145588",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\ud83d\udcdd Training metadata saved to: models\\real_servicenow_finetuned_mpnet_lora\\real_servicenow_v2_20251224_0449\\training_metadata.json\n",
      "\u2705 Training pipeline V2 complete!\n"
     ]
    }
   ],
   "source": [
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "# TRAINING METADATA EXPORT (V2)\n",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "\n",
    "from datetime import datetime\n",
    "import json\n",
    "\n",
    "def save_training_metadata(output_dir: str, config: dict, metrics: dict, \n",
    "                          data_stats: dict, adversarial_results: dict = None,\n",
    "                          error_analysis: dict = None):\n",
    "    \"\"\"\n",
    "    Save comprehensive training metadata for reproducibility (V2: includes error analysis).\n",
    "    \n",
    "    Following project convention: all model outputs include training_metadata.json\n",
    "    \"\"\"\n",
    "    metadata = {\n",
    "        \"training_timestamp\": datetime.now().isoformat(),\n",
    "        \"model_version\": \"V2\",\n",
    "        \"model_name\": config.get('model_name', 'all-mpnet-finetuned'),\n",
    "        \"base_model\": config.get('model_name', 'sentence-transformers/all-mpnet-base-v2'),\n",
    "        \n",
    "        # Hyperparameters\n",
    "        \"hyperparameters\": {\n",
    "            \"epochs\": config.get('epochs'),\n",
    "            \"batch_size\": config.get('batch_size'),\n",
    "            \"learning_rate\": 2e-5,  # V2: Reduced for LoRA fine-tuning\n",
    "            \"max_seq_length\": config.get('max_seq_length'),\n",
    "            \"warmup_ratio\": config.get('warmup_ratio'),\n",
    "            \"loss_function\": \"CosineSimilarityLoss\"  # V2: Changed to use all pairs\n",
    "        },\n",
    "        \n",
    "        # V2: Curriculum learning config\n",
    "        \"curriculum_learning\": {\n",
    "            \"enabled\": config.get('use_curriculum', False),\n",
    "            \"phases\": config.get('curriculum_phases', [])\n",
    "        },\n",
    "        \n",
    "        # Data configuration (V2: stricter thresholds)\n",
    "        \"data_config\": {\n",
    "            \"source_data\": config.get('source_data'),\n",
    "            \"num_pairs\": config.get('num_pairs'),\n",
    "            \"min_text_length\": config.get('min_text_length'),\n",
    "            \"eval_split\": config.get('eval_split'),\n",
    "            \"holdout_split\": config.get('holdout_split'),\n",
    "            \"pos_tfidf_threshold\": config.get('pos_tfidf_threshold'),\n",
    "            \"neg_tfidf_threshold\": config.get('neg_tfidf_threshold'),\n",
    "            \"pair_ratios\": {\n",
    "                \"positives\": config.get('pos_ratio', 0.30),\n",
    "                \"hard_negatives\": config.get('hard_neg_ratio', 0.45),\n",
    "                \"easy_negatives\": config.get('easy_neg_ratio', 0.25)\n",
    "            }\n",
    "        },\n",
    "        \n",
    "        # Data statistics\n",
    "        \"data_statistics\": data_stats,\n",
    "        \n",
    "        # TF-IDF configuration\n",
    "        \"tfidf_config\": {\n",
    "            \"max_features\": 15000,\n",
    "            \"ngram_range\": [1, 2],\n",
    "            \"min_df\": 2,\n",
    "            \"max_df\": 0.95\n",
    "        },\n",
    "        \n",
    "        # Evaluation metrics\n",
    "        \"evaluation_metrics\": metrics,\n",
    "        \n",
    "        # V2: Cross-validated threshold\n",
    "        \"cv_threshold\": {\n",
    "            \"value\": float(cv_threshold) if 'cv_threshold' in dir() else None,\n",
    "            \"std\": float(cv_std) if 'cv_std' in dir() else None,\n",
    "            \"n_folds\": config.get('threshold_cv_folds', 5)\n",
    "        },\n",
    "        \n",
    "        # Adversarial diagnostic results\n",
    "        \"adversarial_diagnostic\": adversarial_results,\n",
    "        \n",
    "        # V2: Error analysis summary\n",
    "        \"error_analysis\": error_analysis,\n",
    "        \n",
    "        # Environment info\n",
    "        \"environment\": {\n",
    "            \"device\": DEVICE,\n",
    "            \"random_seed\": config.get('seed'),\n",
    "            \"python_version\": __import__('sys').version,\n",
    "            \"torch_version\": torch.__version__,\n",
    "            \"transformers_version\": __import__('transformers').__version__,\n",
    "            \"sentence_transformers_version\": __import__('sentence_transformers').__version__\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    metadata_path = os.path.join(output_dir, \"training_metadata.json\")\n",
    "    with open(metadata_path, 'w') as f:\n",
    "        json.dump(metadata, f, indent=2, default=str)\n",
    "    \n",
    "    log(f\"\ud83d\udcdd Training metadata saved to: {metadata_path}\")\n",
    "    return metadata_path\n",
    "\n",
    "# Collect data statistics\n",
    "data_stats = {\n",
    "    \"total_records\": len(df_incidents),\n",
    "    \"train_size\": len(train_df),\n",
    "    \"eval_size\": len(eval_df),\n",
    "    \"holdout_size\": len(holdout_df),\n",
    "    \"unique_categories\": df_incidents['Category'].nunique() if 'Category' in df_incidents.columns else None,\n",
    "    \"unique_subcategories\": df_incidents['Subcategory'].nunique() if 'Subcategory' in df_incidents.columns else None,\n",
    "    \"unique_assignment_groups\": df_incidents['Assignment group'].nunique() if 'Assignment group' in df_incidents.columns else None,\n",
    "    \"avg_text_length\": df_incidents['text'].str.len().mean(),\n",
    "    \"tfidf_vocabulary_size\": None\n",
    "}\n",
    "\n",
    "# Collect metrics\n",
    "try:\n",
    "    eval_metrics = {\n",
    "        \"eval_roc_auc\": float(eval_results['roc_auc']),\n",
    "        \"eval_pr_auc\": float(eval_results['pr_auc']),\n",
    "        \"eval_spearman\": float(eval_results['spearman']),\n",
    "        \"eval_pearson\": float(eval_results['pearson']),\n",
    "        \"eval_f1\": float(eval_results['f1']),\n",
    "        \"holdout_roc_auc\": float(holdout_results['roc_auc']),\n",
    "        \"holdout_pr_auc\": float(holdout_results['pr_auc']),\n",
    "        \"holdout_spearman\": float(holdout_results['spearman']),\n",
    "        \"holdout_pearson\": float(holdout_results['pearson']),\n",
    "        \"holdout_f1\": float(holdout_results['f1']),\n",
    "        # V2: Borderline metrics\n",
    "        \"borderline_roc_auc\": float(borderline_results['roc_auc']),\n",
    "        \"borderline_pr_auc\": float(borderline_results['pr_auc']),\n",
    "        \"borderline_f1\": float(borderline_results['f1']),\n",
    "    }\n",
    "except:\n",
    "    eval_metrics = {\"note\": \"Run evaluation cells first\"}\n",
    "\n",
    "# Collect adversarial results\n",
    "try:\n",
    "    adversarial_results_dict = {\n",
    "        \"roc_auc\": float(adv_results['roc_auc']) if 'adv_results' in dir() else None,\n",
    "        \"f1_score\": float(adv_results['f1']) if 'adv_results' in dir() else None,\n",
    "        \"pass_status\": DIAGNOSTIC_PASSED if 'DIAGNOSTIC_PASSED' in dir() else None\n",
    "    }\n",
    "except:\n",
    "    adversarial_results_dict = {\"note\": \"Run adversarial diagnostic first\"}\n",
    "\n",
    "# V2: Collect error analysis summary\n",
    "try:\n",
    "    error_analysis_dict = {\n",
    "        \"eval_fp_count\": eval_errors['fp_count'],\n",
    "        \"eval_fn_count\": eval_errors['fn_count'],\n",
    "        \"holdout_fp_count\": holdout_errors['fp_count'],\n",
    "        \"holdout_fn_count\": holdout_errors['fn_count'],\n",
    "        \"borderline_fp_count\": borderline_errors['fp_count'],\n",
    "        \"borderline_fn_count\": borderline_errors['fn_count'],\n",
    "    }\n",
    "except:\n",
    "    error_analysis_dict = {\"note\": \"Run error analysis first\"}\n",
    "\n",
    "# Save metadata\n",
    "metadata_path = save_training_metadata(\n",
    "    output_dir=str(save_path),\n",
    "    config=CONFIG,\n",
    "    metrics=eval_metrics,\n",
    "    data_stats=data_stats,\n",
    "    adversarial_results=adversarial_results_dict,\n",
    "    error_analysis=error_analysis_dict\n",
    ")\n",
    "\n",
    "log(\"\u2705 Training pipeline V2 complete!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "633a7ca0",
   "metadata": {},
   "source": [
    "# 10. Usage Examples & V2 Summary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9dc44fe2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\ud83d\udce6 Using model from: memory (just trained: models\\real_servicenow_finetuned_mpnet_lora\\real_servicenow_v2_20251224_0449)\n",
      "\n",
      "============================================================\n",
      "SIMILARITY MATRIX DEMO\n",
      "============================================================\n",
      "\n",
      "Tickets:\n",
      "  [0] User cannot login to SAP system. Error message: authentication failed. Tried res...\n",
      "  [1] SAP login issue - getting access denied error when trying to connect to producti...\n",
      "  [2] Outlook keeps crashing when opening large attachments. Have tried restarting but...\n",
      "  [3] Email client crashes randomly. Users report Outlook freezing when opening emails...\n",
      "  [4] Request to provision new laptop for incoming employee starting next Monday....\n",
      "\n",
      "Similarity Matrix:\n",
      "       [0]    [1]    [2]    [3]    [4]  \n",
      "[0]   1.000  0.678  0.094  0.067  -0.057 \n",
      "[1]   0.678  1.000  0.040  0.006  0.043 \n",
      "[2]   0.094  0.040  1.000  0.781  0.025 \n",
      "[3]   0.067  0.006  0.781  1.000  0.055 \n",
      "[4]   -0.057  0.043  0.025  0.055  1.000 \n",
      "\n",
      "------------------------------------------------------------\n",
      "HIGH SIMILARITY PAIRS (> 0.7):\n",
      "  Tickets [2] & [3]: 0.781\n",
      "    [2]: Outlook keeps crashing when opening large attachments. Have ...\n",
      "    [3]: Email client crashes randomly. Users report Outlook freezing...\n",
      "\n",
      "\n",
      "============================================================\n",
      "\ud83d\udcca V2 IMPROVEMENT SUMMARY\n",
      "============================================================\n",
      "\n",
      "\ud83c\udd95 V2 ENHANCEMENTS IMPLEMENTED:\n",
      "\n",
      "1. HARDER NEGATIVE MINING\n",
      "   \u251c\u2500 Increased hard_neg_ratio: 35% \u2192 45%\n",
      "   \u251c\u2500 Stricter neg_tfidf_threshold: 0.20 \u2192 0.12\n",
      "   \u2514\u2500 Reduced easy negatives: 30% \u2192 25%\n",
      "\n",
      "2. CURRICULUM LEARNING\n",
      "   \u251c\u2500 Phase 1 (Epochs 1-2): Easier pairs (25% hard neg, threshold 0.15)\n",
      "   \u2514\u2500 Phase 2 (Epochs 3-4): Harder pairs (55% hard neg, threshold 0.10)\n",
      "\n",
      "3. BORDERLINE TEST SET\n",
      "   \u251c\u2500 TF-IDF range: 0.25 - 0.35 (ambiguous cases)\n",
      "   \u2514\u2500 Tests model on genuinely difficult pairs\n",
      "\n",
      "4. ERROR ANALYSIS\n",
      "   \u251c\u2500 Identifies worst false positives/negatives\n",
      "   \u251c\u2500 Analyzes text length patterns\n",
      "   \u2514\u2500 Provides systematic failure insights\n",
      "\n",
      "5. CROSS-VALIDATED THRESHOLD\n",
      "   \u251c\u2500 5-fold CV for robust threshold selection\n",
      "   \u2514\u2500 Reports threshold variance across folds\n",
      "\n",
      "NEXT STEPS FOR FURTHER IMPROVEMENT:\n",
      "\n",
      "\n",
      "\ud83d\udcc8 BASED ON RESULTS, CONSIDER:\n",
      "\n",
      "If borderline ROC-AUC < 0.80:\n",
      "   \u2192 Increase curriculum phases to 3 (add intermediate difficulty)\n",
      "   \u2192 Add triplet loss fine-tuning stage\n",
      "\n",
      "If many false negatives on short texts:\n",
      "   \u2192 Reduce min_text_length filter\n",
      "   \u2192 Add text augmentation (paraphrasing)\n",
      "\n",
      "If many false positives on same-category pairs:\n",
      "   \u2192 Increase hard_neg_ratio further (45% \u2192 55%)\n",
      "   \u2192 Remove category context from training text\n",
      "\n",
      "PRODUCTION DEPLOYMENT:\n",
      "   \u2192 Model path: models/real_servicenow_finetuned_mpnet_lora\n",
      "   \u2192 Use CV threshold: 0.3228 (\u00b1 0.0634)\n",
      "   \u2192 Pre-compute embeddings for ticket corpus\n",
      "\n",
      "\u2705 V2 training and evaluation complete!\n"
     ]
    }
   ],
   "source": [
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "# USAGE EXAMPLES & V2 SUMMARY\n",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "\n",
    "def demonstrate_model_usage():\n",
    "    \"\"\"\n",
    "    Demonstrate how to use the fine-tuned model for ITSM ticket similarity.\n",
    "    \"\"\"\n",
    "    from sentence_transformers import SentenceTransformer\n",
    "    from sklearn.metrics.pairwise import cosine_similarity\n",
    "    import os\n",
    "    from pathlib import Path\n",
    "    \n",
    "    # Try to use best_model if available (just trained), otherwise load from disk\n",
    "    if 'best_model' in globals():\n",
    "        model = globals()['best_model']\n",
    "        model_source = f\"memory (just trained: {globals()['save_path']})\"\n",
    "    else:\n",
    "        # Get output directory\n",
    "        if 'CONFIG' in globals():\n",
    "            output_dir = globals()['CONFIG']['output_dir']\n",
    "        else:\n",
    "            output_dir = 'models/real_servicenow_finetuned_v2'\n",
    "            log(\"\u26a0\ufe0f CONFIG not loaded. Using default model directory.\")\n",
    "        \n",
    "        # Look for most recent trained model\n",
    "        base_dir = Path(output_dir)\n",
    "        if base_dir.exists():\n",
    "            model_dirs = [d for d in base_dir.iterdir() if d.is_dir() and d.name.startswith('real_servicenow_')]\n",
    "            if model_dirs:\n",
    "                latest_model = max(model_dirs, key=lambda d: d.stat().st_mtime)\n",
    "                log(f\"\ud83d\udcc2 Loading most recent trained model from: {latest_model}\")\n",
    "                model = SentenceTransformer(str(latest_model))\n",
    "                model_source = str(latest_model)\n",
    "            else:\n",
    "                log(\"\u274c No trained model found. Please run training cells first.\")\n",
    "                return None, None\n",
    "        else:\n",
    "            log(\"\u274c No trained model found. Please run training cells first.\")\n",
    "            return None, None\n",
    "    \n",
    "    log(f\"\ud83d\udce6 Using model from: {model_source}\")\n",
    "    \n",
    "    # Example tickets\n",
    "    example_tickets = [\n",
    "        \"User cannot login to SAP system. Error message: authentication failed. Tried resetting password but issue persists.\",\n",
    "        \"SAP login issue - getting access denied error when trying to connect to production system.\",\n",
    "        \"Outlook keeps crashing when opening large attachments. Have tried restarting but problem continues.\",\n",
    "        \"Email client crashes randomly. Users report Outlook freezing when opening emails with attachments.\",\n",
    "        \"Request to provision new laptop for incoming employee starting next Monday.\",\n",
    "    ]\n",
    "    \n",
    "    # Encode all tickets\n",
    "    embeddings = model.encode(example_tickets, show_progress_bar=False)\n",
    "    \n",
    "    # Compute similarity matrix\n",
    "    sim_matrix = cosine_similarity(embeddings)\n",
    "    \n",
    "    # Display results\n",
    "    log(\"\\n\" + \"=\"*60)\n",
    "    log(\"SIMILARITY MATRIX DEMO\")\n",
    "    log(\"=\"*60)\n",
    "    \n",
    "    print(\"\\nTickets:\")\n",
    "    for i, ticket in enumerate(example_tickets):\n",
    "        print(f\"  [{i}] {ticket[:80]}...\")\n",
    "    \n",
    "    print(\"\\nSimilarity Matrix:\")\n",
    "    print(\"     \", end=\"\")\n",
    "    for i in range(len(example_tickets)):\n",
    "        print(f\"  [{i}]  \", end=\"\")\n",
    "    print()\n",
    "    \n",
    "    for i, row in enumerate(sim_matrix):\n",
    "        print(f\"[{i}]  \", end=\"\")\n",
    "        for val in row:\n",
    "            print(f\" {val:.3f} \", end=\"\")\n",
    "        print()\n",
    "    \n",
    "    # Find similar ticket pairs\n",
    "    log(\"\\n\" + \"-\"*60)\n",
    "    log(\"HIGH SIMILARITY PAIRS (> 0.7):\")\n",
    "    for i in range(len(example_tickets)):\n",
    "        for j in range(i+1, len(example_tickets)):\n",
    "            if sim_matrix[i][j] > 0.7:\n",
    "                print(f\"  Tickets [{i}] & [{j}]: {sim_matrix[i][j]:.3f}\")\n",
    "                print(f\"    [{i}]: {example_tickets[i][:60]}...\")\n",
    "                print(f\"    [{j}]: {example_tickets[j][:60]}...\")\n",
    "                print()\n",
    "    \n",
    "    return model, embeddings\n",
    "\n",
    "# Run demonstration\n",
    "demo_model, demo_embeddings = demonstrate_model_usage()\n",
    "\n",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "# V2 IMPROVEMENT SUMMARY\n",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n",
    "\n",
    "log(\"\\n\" + \"=\"*60)\n",
    "log(\"\ud83d\udcca V2 IMPROVEMENT SUMMARY\")\n",
    "log(\"=\"*60)\n",
    "\n",
    "print(\"\"\"\n",
    "\ud83c\udd95 V2 ENHANCEMENTS IMPLEMENTED:\n",
    "\n",
    "1. HARDER NEGATIVE MINING\n",
    "   \u251c\u2500 Increased hard_neg_ratio: 35% \u2192 45%\n",
    "   \u251c\u2500 Stricter neg_tfidf_threshold: 0.20 \u2192 0.12\n",
    "   \u2514\u2500 Reduced easy negatives: 30% \u2192 25%\n",
    "\n",
    "2. CURRICULUM LEARNING\n",
    "   \u251c\u2500 Phase 1 (Epochs 1-2): Easier pairs (25% hard neg, threshold 0.15)\n",
    "   \u2514\u2500 Phase 2 (Epochs 3-4): Harder pairs (55% hard neg, threshold 0.10)\n",
    "\n",
    "3. BORDERLINE TEST SET\n",
    "   \u251c\u2500 TF-IDF range: 0.25 - 0.35 (ambiguous cases)\n",
    "   \u2514\u2500 Tests model on genuinely difficult pairs\n",
    "\n",
    "4. ERROR ANALYSIS\n",
    "   \u251c\u2500 Identifies worst false positives/negatives\n",
    "   \u251c\u2500 Analyzes text length patterns\n",
    "   \u2514\u2500 Provides systematic failure insights\n",
    "\n",
    "5. CROSS-VALIDATED THRESHOLD\n",
    "   \u251c\u2500 5-fold CV for robust threshold selection\n",
    "   \u2514\u2500 Reports threshold variance across folds\n",
    "\n",
    "NEXT STEPS FOR FURTHER IMPROVEMENT:\n",
    "\"\"\")\n",
    "\n",
    "print(f\"\"\"\n",
    "\ud83d\udcc8 BASED ON RESULTS, CONSIDER:\n",
    "\n",
    "If borderline ROC-AUC < 0.80:\n",
    "   \u2192 Increase curriculum phases to 3 (add intermediate difficulty)\n",
    "   \u2192 Add triplet loss fine-tuning stage\n",
    "\n",
    "If many false negatives on short texts:\n",
    "   \u2192 Reduce min_text_length filter\n",
    "   \u2192 Add text augmentation (paraphrasing)\n",
    "\n",
    "If many false positives on same-category pairs:\n",
    "   \u2192 Increase hard_neg_ratio further (45% \u2192 55%)\n",
    "   \u2192 Remove category context from training text\n",
    "\n",
    "PRODUCTION DEPLOYMENT:\n",
    "   \u2192 Model path: {CONFIG['output_dir']}\n",
    "   \u2192 Use CV threshold: {cv_threshold:.4f} (\u00b1 {cv_std:.4f})\n",
    "   \u2192 Pre-compute embeddings for ticket corpus\n",
    "\"\"\")\n",
    "\n",
    "log(\"\u2705 V2 training and evaluation complete!\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "itsm",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.14"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}